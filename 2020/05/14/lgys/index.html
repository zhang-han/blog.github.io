<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 灵光一闪 · Hexo</title><meta name="description" content="灵光一闪 - Zhh"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">灵光一闪</h1><div class="post-info">2020年5月14日</div><div class="post-content"><p>不想写标题</p>
<a id="more"></a>
<h2 id="《Android架构师实战指南》灵光一闪总结"><a href="#《Android架构师实战指南》灵光一闪总结" class="headerlink" title="《Android架构师实战指南》灵光一闪总结"></a>《Android架构师实战指南》灵光一闪总结</h2><ul>
<li>架构的核心就是功能、安全、性能和稳定。</li>
<li>架构师需要考虑的点有：具备客户要求的功能、能够在要求的工期内安全的构建、性能足够好、可靠、可用且使用时不会造成伤害、安全、成本可接受、符合法规标准、将超越前任以及其他竞争者。</li>
<li>架构师玩的是折中的游戏，需要根据现有情况、条件、需求来找到一个最好的平衡点，所以没有唯一的正确架构和唯一的正确答案。</li>
</ul>
<h3 id="知识点篇"><a href="#知识点篇" class="headerlink" title="知识点篇"></a>知识点篇</h3><ul>
<li>多继承方式：使用内部类进行继承，可是实现多继承，例如MyApplication继承BasicApplication，内部类Application继承BaseApplication。</li>
<li>使用代理模式可进行bug统计和log输出，特别好用，也可用于使用在方法过滤中。</li>
<li>当大量使用第三方网络库时，良好的习惯是封装、封装、封装。因为只有自己封装一层，才能够统一实现入口的逻辑。</li>
</ul>
<h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><ul>
<li>UML图工具：Enterprise Architect、Gliffy</li>
<li>思维导图：XMind、iMindMap</li>
<li>原型设计：Axure、OmniGraffle（Mac）、Justinmind</li>
<li>产品演示：PPT</li>
<li>图像绘制：Visio、Adobe系列（PS/AI/AE)、Keynote、Pixate(交互设计)</li>
<li>辅助工具：MarkMan、Sip、石墨文档（在线协作文档）、Google Drive（文档协作/项目管理）</li>
<li>抓包工具：fillder、Charles</li>
</ul>
<h3 id="设备卡顿原因与处理"><a href="#设备卡顿原因与处理" class="headerlink" title="设备卡顿原因与处理"></a>设备卡顿原因与处理</h3><ul>
<li>设备卡顿一般情况下是由于CPU、GPU、内存、线程导致的app卡顿。<ul>
<li>CPU与GPU造成的卡顿可以在UI和布局上进行优化，减少无用的view构建可以减少CPU的压力，减少无用的绘制可以减少GPU的压力。在view绘制流程中，减少onLayout与onMeasure中的工作量会减少CPU的压力，减少onDraw中的工作量会减少GPU的压力。</li>
<li>内存，内存优化与处理，尽量使用懒加载，减少超大图片的使用，详见内存机制与原理篇。</li>
<li>线程，主要是ANR（Application Not Responding，应用无响应）状态，可以减少Service、Broadcast Receiver的数量和初始化状态，采用懒加载。减少应用瞬时的初始化数量。</li>
</ul>
</li>
</ul>
<h3 id="java内存机制"><a href="#java内存机制" class="headerlink" title="java内存机制"></a>java内存机制</h3><h4 id="java内存区域-分为方法区、堆、栈、以及程序计数器"><a href="#java内存区域-分为方法区、堆、栈、以及程序计数器" class="headerlink" title="java内存区域 分为方法区、堆、栈、以及程序计数器"></a>java内存区域 分为方法区、堆、栈、以及程序计数器</h4><ul>
<li>方法区（Method Area） 最大容量64MB，主要存放方法、属性、静态成员等。所有线程共享内存区域，属于持久代。<ul>
<li>在 JDK1.8中，为防止方法区内存溢出，将方法区改为元数据区，并将其放到了对外内存（本地内存）中了，那么他的大小就不在受限于JVM了。</li>
</ul>
</li>
<li>堆（Heap） 最大容量64MB，存放对象所持有的数据，同时保持对原类的引用。所有线程共享内存区域。</li>
<li>栈（Stack） 分为虚拟机栈（JVM Stacks）与本地方法栈（Native Method Stacks）。默认最大容量1MB，方法被调用后，java虚拟机（JVM）会回收栈占用的内存，线程私有内存区域。<ul>
<li>虚拟机栈（JVM Stacks）用于存储局部变量、动态链接、操作数、方法出口等信息。有两种异常情况StackOverFlowError、OutOfMemoryError。</li>
<li>本地方法栈（Native Method Stacks）主要为Native提供方法服务，</li>
</ul>
</li>
<li>程序计数器（Program Counter Register）可以看做是当前线程执行字节码的行号指示器，位于CPU中，程序不能直接对其操作，每个线程都有独立的计数器，线程私有内存区域。</li>
<li>GC。Garbage Collection/Collector,垃圾回收/回收器。用户分配内存，确保被引用对象保留在内存中，以及回收不存在引用关系的对象内存，基本算法是分代收集，针对内存区域中的本地方法栈与对进行回收，新生代、旧生代、长久代采用不用的GC算法。</li>
</ul>
<h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><ul>
<li>内存溢出通常是由于内存泄漏导致，或者加重超大图片资源bitmap导致内存溢出问题</li>
<li>内存泄漏，我们都知道，当一个对象在jvm中如果没有到达GC roots（根对象）的路径时为不可达状态，不可达状态时会被GC回收，而内存泄漏就是指某些对象可达却无用的状态。这时就要通过工具（profiler）进行内存跟踪，并结合代码进行梳理找到内存泄漏原因。<ul>
<li>持有Activity、Context、View、Drawable这些对象时，不要去处理Theard、第三方初始化或异步程序。当异步程序生命周期大于当前生命周期时会导致内存泄漏。</li>
<li>内部类、匿名类等。道理同上，内部类或匿名类可能因为生命周期不同步，造成一定程度的内存泄漏。</li>
</ul>
</li>
<li>内存优化<ul>
<li>减少Service的使用，尽力使用IntentService进行服务的工作。</li>
<li>监听内存使用情况，当UI不可见或内存紧张时释放内存。在Activity的回调方法onTrimMemory(int level)中，根基level的不同释放内存。</li>
<li>使用bitmap时要尽力保证分辨率与屏幕分辨率一致。</li>
<li>使用SparseArray、SparseBooleanArray、LongSparseArray等优化的数据容器代替HashMap</li>
<li>少使用抽象类</li>
<li>尽量少使用依赖注入的工具类</li>
<li>apk打包签名时，使用zipalign工具对齐</li>
<li>使用多线程</li>
<li>主动使用GC</li>
<li>finally调用与重写</li>
</ul>
</li>
</ul>
<h3 id="app保活"><a href="#app保活" class="headerlink" title="app保活"></a>app保活</h3><p>app保活指的是保护app，让app活着，在android OS发展越来越快和越来越严格的环境下，如今保活已经是一种奢望，但是提高app的保活率和提高保活状态还是可以的。</p>
<p>android中主要通过LMK（Low Memory Killer）来对进程进行回收管理，LMK是在Android系统内存不足而选择kill部分进程以释放空间的决定者。</p>
<h4 id="app被系统回收或杀死优先级"><a href="#app被系统回收或杀死优先级" class="headerlink" title="app被系统回收或杀死优先级"></a>app被系统回收或杀死优先级</h4><ul>
<li>前台进程，正在与用户进行交互的进程。</li>
<li>可见进程，会影响用户所见内容的进程，如处于onPause的Activity。</li>
<li>服务进程，如正在运行startService的Service。</li>
<li>后台进程，对用户交互无影响，例如处于onStop的activity。</li>
<li>空进程，一般作用缓存，以缩短下次使用时间，例如被切到后台的后台进程，然后被系统回收，但是处于温启动状态下的app。</li>
</ul>
<h4 id="保活方法"><a href="#保活方法" class="headerlink" title="保活方法"></a>保活方法</h4><p>有上面的优先级可知进程被杀死或回收的顺序，和LMK的回收原理，那么如果提高app的优先级则可以有效提高app的保活率。</p>
<p>前台进程、可见进程属于不可控方向。所以我们需要尽量保证app处于服务进程或后台进程，避免app处于空进程中。</p>
<ul>
<li>网络连接保活方法，建立长连接</li>
<li>双service（通知栏）提高进程优先级</li>
<li>Service及时拉起</li>
<li>守护进程、进程互拉</li>
</ul>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>looper翻译一下是回路、循环的意思。在android中也一样，代表一个可以无限的死循环。</p>
<ul>
<li>启动过程<ul>
<li>looper创建时会同时创建一个MessageQueue，每个线程有一个looper、一个MessageQueue、多个Handler</li>
<li>主线程：<ul>
<li>主线程中会自动创建looper，即执行looper.prepare(),looper.loop();</li>
<li>当主线程的looper退出循环，则意味着主线程结束，程序退出</li>
</ul>
</li>
<li>子线程：<ul>
<li>子线程的looper可有可无，在需要的时候创建，然后looper.loop()开始循环，代表着无限死循环执行下去。如果再looper.loop()后面写的代码不会执行。</li>
<li>子线程中如果要写handler，则必须有looper，因为在handler的构造方法中，会执行Looper.myLooper()；方法，如果获取looper为空，则会抛出异常RuntimeException。</li>
</ul>
</li>
</ul>
</li>
<li>looper循环<ul>
<li>在looper创建(looper.prepare())之后，looper循环(looper.loop())之前的代码会无限死循环执行。</li>
<li>在Android中，生命周期的回调、方法的执行、交互的方式等等都是通过looper的循环进行message事件的分发。</li>
<li>在子线程如果创建了looper，且looper退出循环代表子线程结束</li>
<li>在主线程中必然存在looper，如果退出了looper循环，代表主线程结束，程序退出</li>
<li>每个线程至多只有一个looper，主线程必定有looper，子线程不一定有looper。</li>
<li>每个handler的创建必然有looper，子线程的handler创建需要先创建looper.prepare()，然后创建handler，然后执行looper.loop()才能够创建并执行handler机制。</li>
</ul>
</li>
<li>当Looper从MessageQueue中摘取消息时，如果队列上没有消息，则looper线程会进入阻塞，知道其他线程插入消息后，唤醒当前线程才会继续执行。</li>
<li>looper的退出<ul>
<li>主线程：主线程的looper是不能够退出的</li>
<li>子线程：子线程有quit和quitSafely两种退出方式，本质都是调用quit(boolean safe)方法进行退出，再往下调用的两个方法是：<ul>
<li>removeAllFutureMessagesLocked();清空延时消息，不延时的消息，依旧让他执行完，再退出</li>
<li>removeAllMessagesLocked();全部清空，并退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><ul>
<li>MessageQueue是在Looper创建时同时创建的一个消息队列</li>
<li>在使用Handler进行消息插入时，最后Handler会调用handler.sendMessageAiTime();通过looper将message插入到MessageQueue中，所以looper、MessageQueue都是添加同步锁的</li>
<li>MessageQueue中的默认Message线程池线程数量为50，在Message线程池消息池中主要方法有两个，obtain和recycle，且方法是需要加同步锁的。<ul>
<li>obtain：负责从线程池中取出一个干净的Message</li>
<li>recycl：后者将使用完的Message清理干净，并放回线程池中</li>
</ul>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>java中一般认为有23种设计模式，我们不需要都体会，只需要掌握及种设计模式就可以了。</li>
<li>创建型模式，共五种：工长方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
<li>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li>
<li>行为型模式，共十一种：侧罗模式、模板方式模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式分为懒汉式、饿汉式。</p>
<ul>
<li>饿汉式：饿汉式实在声明静态全局变量时，就直接将该单例对象new出来的方式。</li>
<li>懒汉式：声明变量时不会直接创建对象本身，而是在构造方法中进行线程安全处理，加入synchronized锁，并在声明变量时使用volatile进行修饰。</li>
</ul>
<h4 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h4><ul>
<li>工厂设计模式分为工厂方法模式和抽象工厂模式</li>
<li>封装很多的overview可以认为是一种工厂模式的典型使用，通过定义overview进行工厂基础的封装，然后其他overview实现该接口进行不同功能的具体实现</li>
</ul>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><ul>
<li>普通工厂模式就是建立一个工厂类，对实现了统一接口的一些类进行实例的创建</li>
<li>多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 </li>
<li>静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5></li>
<li>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</li>
</ul>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><ul>
<li>建造者模式通过builder将对象build出来，然后通过简单的方式将对象进行处理</li>
<li>例如地图量测小工具，通过build进行创建，并使用小工具进行量测功能</li>
</ul>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><ul>
<li>适配器模式可以认为是简易化的中间件，具体是将两个不兼容的对象通过适配器进行联通并使用</li>
</ul>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><ul>
<li>观察者模式的核心是接口回调，而接口回调也可以认为是简单的观察者模式。</li>
<li>例如定位组件的监听器，通过注册的方式使观察者注册进来，观察被观察者定位的改变。</li>
</ul>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><ul>
<li>策略模式可以使封装一个统一的接口，然后其他的具体实现使用这个接口进行具体实现，外部调用方式都是同一个方法</li>
<li>量测模块中的具体算法量测calcalator可以认为是一个策略模式，使用不同的计算模块实现计算方式</li>
</ul>
<h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><ul>
<li>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>设计模式是一种认为定制的模式，而在实际开发中，在不理解或没有认知到某些模式的时候，已经无意间使用了很多的模式。不要因为要使用某种模式而去使用模式，应该是在开发过程中顺其自然的使用了某种模式后根据这种模式去完善。</li>
<li>设计模式的初衷是提高代码效率，高内部低耦合的原则。</li>
</ul>
<h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><ul>
<li>不要重复造轮子，网络库很好，如果不好一定是没找好，既然好为什么不用呢。不要把精力放在重复的事情上。</li>
<li>专业的事情交给专业的人去做。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2020/06/03/FBS_LGYS/" class="prev">上一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">Zhh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>