<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-12T09:26:46.292Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mapbox Demo 学习记录</title>
    <link href="http://yoursite.com/2020/06/12/Mapbox%20Demo%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/12/Mapbox%20Demo%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-12T09:27:24.434Z</published>
    <updated>2020-06-12T09:26:46.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mapbox-Demo-学习记录"><a href="#Mapbox-Demo-学习记录" class="headerlink" title="Mapbox Demo 学习记录"></a>Mapbox Demo 学习记录</h1><hr><p>[TOC]</p><h2 id="v6-2-0版本基础"><a href="#v6-2-0版本基础" class="headerlink" title="v6.2.0版本基础"></a>v6.2.0版本基础</h2><ul><li>要使代码可运行，需要调整项目根目录下build.gradle中两个maven仓库的顺序，因为有个GifView的库在第一个maven库”<a href="https://jitpack.io&quot;中有错误，但在第二个maven库&quot;http://oss.sonatype.org/content/repositories/snapshots/&quot;中可以使用。" target="_blank" rel="noopener">https://jitpack.io&quot;中有错误，但在第二个maven库&quot;http://oss.sonatype.org/content/repositories/snapshots/&quot;中可以使用。</a></li></ul><h4 id="DDS—GeoJsonClusteringActivity：聚合1万多个Point-Geometry-示例。-mapbox聚合只能聚合只含有Point的geojson，若geojson中含有LineString、-Polygon都将无法聚合。"><a href="#DDS—GeoJsonClusteringActivity：聚合1万多个Point-Geometry-示例。-mapbox聚合只能聚合只含有Point的geojson，若geojson中含有LineString、-Polygon都将无法聚合。" class="headerlink" title="DDS—GeoJsonClusteringActivity：聚合1万多个Point Geometry 示例。 mapbox聚合只能聚合只含有Point的geojson，若geojson中含有LineString、 Polygon都将无法聚合。"></a>DDS—GeoJsonClusteringActivity：聚合1万多个Point Geometry 示例。 mapbox聚合只能聚合只含有Point的geojson，若geojson中含有LineString、 Polygon都将无法聚合。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在新建Source时，除了添加source_id, source_resource, 传入下面第三个参数</span><br><span class="line">      New GeoJsonOptions().withCluster(true).withClusterMaxZoom(14).withClusterRadius(50)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 获取聚合个数</span><br><span class="line">      Expression pointCount &#x3D; toNumber(get(&quot;point_count&quot;)); </span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 根据需要添加Layer(一般三个层)</span><br><span class="line">      a.  &quot;unclustered-points&quot;: 没有聚合在一起的Point正常显示的Layer</span><br><span class="line">      b.  &quot;cluster-&quot; + i      : 针对不同情况聚合在一起显示的Layer，例如通过pointCount来判断在那个范围显示哪个颜色</span><br><span class="line">      c.  &quot;count&quot;             : 通过 &quot;&#123;point_count&#125;&quot; 来显示文字个数</span><br></pre></td></tr></table></figure><h4 id="DDS—AddRainFallStyleActivity：数据时间推移"><a href="#DDS—AddRainFallStyleActivity：数据时间推移" class="headerlink" title="DDS—AddRainFallStyleActivity：数据时间推移"></a>DDS—AddRainFallStyleActivity：数据时间推移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 利用VectorSource加载 &quot;mapbox:&#x2F;&#x2F;shenhongissky.6vm8ssjm&quot;</span><br><span class="line">VectorSource vectorSource &#x3D; new VectorSource(&quot;moji-source&quot;, &quot;mapbox:&#x2F;&#x2F;shenhongissky.6vm8ssjm&quot;);</span><br><span class="line">mapboxMap.addSource(vectorSource);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加FillLayer</span><br><span class="line">layer &#x3D; new FillLayer(&quot;moji-layer&quot;, &quot;moji-source&quot;);</span><br><span class="line">layer.withSourceLayer(&quot;whole&quot;);                      &#x2F;&#x2F; 这句不懂，很难很难</span><br><span class="line">layer.setFilter(eq((get(&quot;idx&quot;)), literal(0)));       &#x2F;&#x2F; 获取Source中&quot;idx&quot;字段对应值和 字面意思的&quot;0&quot; 相同即可</span><br><span class="line">layer.setProperties(PropertyFactory.visibility(VISIBLE),</span><br><span class="line">      fillColor(interpolate(Expression.exponential(1f),    &#x2F;&#x2F; 指数函数变化，但传值是1f，其实相当于线性变化linear()</span><br><span class="line">        get(&quot;value&quot;), &#x2F;&#x2F; Source中获取value值，根据值在下面stop中选择颜色</span><br><span class="line">        stop(8, Expression.rgb(20, 160, 240)),</span><br><span class="line">        stop(18, Expression.rgb(20, 190, 240)),</span><br><span class="line">        stop(36, Expression.rgb(20, 220, 240)),</span><br><span class="line">        stop(54, Expression.rgb(20, 250, 240)),</span><br><span class="line">        stop(72, Expression.rgb(20, 250, 160)),</span><br><span class="line">        stop(90, Expression.rgb(135, 250, 80)),</span><br><span class="line">        stop(108, Expression.rgb(250, 250, 0)),</span><br><span class="line">        stop(126, Expression.rgb(250, 180, 0)),</span><br><span class="line">        stop(144, Expression.rgb(250, 110, 0)),</span><br><span class="line">        stop(162, Expression.rgb(250, 40, 0)),</span><br><span class="line">        stop(180, Expression.rgb(180, 40, 40)),</span><br><span class="line">        stop(198, Expression.rgb(110, 40, 80)),</span><br><span class="line">        stop(216, Expression.rgb(80, 40, 110)),</span><br><span class="line">        stop(234, Expression.rgb(50, 40, 140)),</span><br><span class="line">        stop(252, Expression.rgb(20, 40, 170))</span><br><span class="line">        )</span><br><span class="line">      ),</span><br><span class="line">      PropertyFactory.fillOpacity(0.7f));                  &#x2F;&#x2F; 透明度</span><br><span class="line">    mapboxMap.addLayer(layer);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 利用Handler，Runnable以及FillLayer.setFilter来不断刷新Layer，自增index到40后重新置0</span><br><span class="line">a.  handler确保一秒中执行一次runnable</span><br><span class="line">b.  runnable中改变setFilter并将index自增</span><br><span class="line">c.  layer.setFilter(eq((get(&quot;idx&quot;)), literal(index)));   &#x2F;&#x2F; 获取Source中&quot;idx&quot;字段对应值和 字面意思的index 相同即可</span><br></pre></td></tr></table></figure><h4 id="DDS-BathymetryActivity-等水深区域使用FillLayer显示，并显示geojson文件中的水深数字"><a href="#DDS-BathymetryActivity-等水深区域使用FillLayer显示，并显示geojson文件中的水深数字" class="headerlink" title="DDS-BathymetryActivity : 等水深区域使用FillLayer显示，并显示geojson文件中的水深数字"></a>DDS-BathymetryActivity : 等水深区域使用FillLayer显示，并显示geojson文件中的水深数字</h4><pre><code>略(太简单)</code></pre><h4 id="Lab-MarkerFollowingRouteActivity-：-marker随着路线移动"><a href="#Lab-MarkerFollowingRouteActivity-：-marker随着路线移动" class="headerlink" title="Lab-MarkerFollowingRouteActivity ： marker随着路线移动"></a>Lab-MarkerFollowingRouteActivity ： marker随着路线移动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加载本地数据利用AsyncTask</span><br><span class="line">a.  doInBackground中将assets下的geojson文件转为String，利用Json解析获取路线集合</span><br><span class="line">b.  doPostExecute中将路线集合利用Polyline添加到地图上</span><br><span class="line">c.  利用Handler和Runnable，通过ValueAnimator不断更新Marker位置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 距离计算</span><br><span class="line">distance &#x3D; (long) marker.getPosition().distanceTo(points.get(count)) * 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 属性动画创建</span><br><span class="line">ValueAnimator markerAnimator &#x3D; ObjectAnimator.ofObject(marker, &quot;position&quot;,</span><br><span class="line">                new LatLngEvaluator(), marker.getPosition(), points.get(count));</span><br><span class="line">          markerAnimator.setDuration(distance);  &#x2F;&#x2F; 动画执行时长就是上面计算distance</span><br><span class="line">          markerAnimator.setInterpolator(new LinearInterpolator());</span><br><span class="line">          markerAnimator.start();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 刷新Marker</span><br><span class="line">          map.getMarkerViewManager().update();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; handler循环执行</span><br><span class="line">          handler.postDelayed(this, distance);</span><br></pre></td></tr></table></figure><h2 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 虚线绘制，后面传Float数组，数组第一个值为实线长度，第二个值为间隔虚线长度</span><br><span class="line">lineDasharray(new Float[]&#123;5f, 1f&#125;)      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 双线条设置，其实是设置中间空心的宽度</span><br><span class="line">lineGapWidth(6.2f)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 控制Layer隐藏显示</span><br><span class="line">   PropertyFactory.visibility(Property.NONE)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 设置CircleLayer边缘模糊</span><br><span class="line">   PropertyFactory.circleBlur(1f)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Expression构造</span><br><span class="line">   interpolate();    &#x2F;&#x2F; 最最难, 暂时不写, 它的构造需要下面的简单构造拼凑使用</span><br><span class="line"></span><br><span class="line">   match();          &#x2F;&#x2F; 传三参, 参数1: 数据源，例如get(&quot;congestion&quot;)；</span><br><span class="line">     &#x2F;&#x2F; 参数2: 返回的默认值</span><br><span class="line">     &#x2F;&#x2F; 参数3: 可列参数，stop()对象, 各种值返回对应需求</span><br><span class="line"></span><br><span class="line">   step();           &#x2F;&#x2F; 传三参, 类似于match(), 但是它的返回值不像match那么固定, 是在值的范围之间来确定取哪个需求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   exponential(1f);  &#x2F;&#x2F; 指数函数变化                      linear();          &#x2F;&#x2F; 线性函数变化</span><br><span class="line">   zoom();           &#x2F;&#x2F; 根据地图缩放级别变化               get(&quot;filed&quot;);      &#x2F;&#x2F; 根据filed的内容获取在Source中它对应的值</span><br><span class="line">   stop();           &#x2F;&#x2F; 阶段值设置  eq();              &#x2F;&#x2F; 相当于String的equals</span><br><span class="line">   gte();            &#x2F;&#x2F; 大于等于  lte();             &#x2F;&#x2F; 小于等于</span><br><span class="line">   gt();             &#x2F;&#x2F; 大于                             lt();              &#x2F;&#x2F; 小于</span><br><span class="line">   literal(&quot;content&quot;)&#x2F;&#x2F; 将内容直接转为Expression          rgba();            &#x2F;&#x2F; 构造颜色</span><br><span class="line">   neq();            &#x2F;&#x2F; 不相同                           all();             &#x2F;&#x2F; 由eq,neq,gte,lte,gt,lt中的两个或两个以上构造</span><br><span class="line">   toNumber();       &#x2F;&#x2F; 经内容转为数字                    toColor();         &#x2F;&#x2F; 将String转为ColorInt</span><br><span class="line">   color();          &#x2F;&#x2F; 传ColorInt</span><br></pre></td></tr></table></figure><h2 id="Mapbox导航"><a href="#Mapbox导航" class="headerlink" title="Mapbox导航"></a>Mapbox导航</h2><ul><li>问题1：我们的mapbox aar包在引用mapbox-android-navigation后access_token无法通过验证<ul><li>问题2：使用mapbox sdk加载我们的地图样式后无法添加文字Layer，即textField(“content”)</li></ul></li><li>问题3：使用我们的mapbox aar加载我们的地图样式后无法添加文字Layer，即textField(“content”)<ul><li>问题4：mapbox sdk最新版本7.3.2没有对StyleUrl的设置，只能通过代码mapBoxMap.setStyle()设置样式，addSource和addLayer都要通过mapBoxMap.getStyle()来添加</li></ul></li><li>问题5：实例化NavigationMapboxMap(mapbox导航UI对象）需要theme继承NavigationViewLight或者NavigationViewDark，或者写自己的样式，但要定义和导航相关的属性</li><li>问题6：0.36.0 导航版本，failed to connect to api.mapbox.com/13.35.13.134 (port 443) after 10000ms 获取导航路线失败，这是由于地图样式需要是mapbox的</li></ul><h4 id="导航UI关键类介绍"><a href="#导航UI关键类介绍" class="headerlink" title="导航UI关键类介绍"></a>导航UI关键类介绍</h4><ul><li><p>NavigationMapboxMap: 管理UI的总类</p><ul><li>drawRoutes()     画路线方法</li></ul></li><li><p>NavigationMapRoute： 具体画路线的类</p><ul><li>addRoutes()      画路线方法</li></ul></li><li><p>MapRouteLine：       定义线的颜色，样式等等，并画</p></li><li><p>MapRouteDrawableProvider：    导航路线需要的drawable资源提供者</p></li><li><p>MapRouteSourceProvider  ：    Mapbox Source提供者</p></li><li><p>MapRouteLayerProvider   ：    Mapbox Layer提供者</p></li><li><p>MapRouteArrow：      未看到在UI上的具体体现</p></li><li><p>MapRouteClickListener：    导航路线单击事件</p></li><li><p>MapRouteProgressChangeListener：    导航路线进度变化事件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;**</span><br><span class="line">   * origin: 起点Point</span><br><span class="line">   * destination: 终点Point</span><br><span class="line">   * bearing: 起点位置的起始角度</span><br><span class="line">   * BEARING_TOLERANCE: 起点角度容忍误差，常量90.0</span><br><span class="line">   * accessToken: 在Mapbox官网申请的Key</span><br><span class="line">   * alternatives: 可供选择的路线，是否获取多条路线</span><br><span class="line">   * this: 一个回调Callback&lt;DirectionsResponse&gt;</span><br><span class="line">   *&#x2F;</span><br><span class="line">   private fun find(location: Location, destination: Point) &#123;</span><br><span class="line">    val origin &#x3D; Point.fromLngLat(location.longitude, location.latitude)</span><br><span class="line">    val bearing &#x3D; location.bearing.toDouble()</span><br><span class="line">    NavigationRoute.builder(NavigationApplication.instance)</span><br><span class="line">            .accessToken(accessToken)</span><br><span class="line">            .origin(origin, bearing, BEARING_TOLERANCE)</span><br><span class="line">            .destination(destination)</span><br><span class="line">            .alternatives(true)</span><br><span class="line">            .build()</span><br><span class="line">            .getRoute(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4418502.256927514  465792.63280210644    |   4419364.046259624  380272.2526359856</span><br><span class="line">4418502.256927514  465792.63280210644    |   4419364.046259624  380272.2526359856</span><br></pre></td></tr></table></figure><h2 id="v6-2-1版本基础"><a href="#v6-2-1版本基础" class="headerlink" title="v6.2.1版本基础"></a>v6.2.1版本基础</h2><h4 id="直接运行Demo可正常运行"><a href="#直接运行Demo可正常运行" class="headerlink" title="直接运行Demo可正常运行"></a>直接运行Demo可正常运行</h4><h4 id="dds-InfoWindowSymbolLayerActivity-地图上的点-增加自定义的InfoWindow"><a href="#dds-InfoWindowSymbolLayerActivity-地图上的点-增加自定义的InfoWindow" class="headerlink" title="dds-InfoWindowSymbolLayerActivity(地图上的点 增加自定义的InfoWindow)"></a>dds-InfoWindowSymbolLayerActivity(地图上的点 增加自定义的InfoWindow)</h4><ul><li><p>在地图已加载方法中 通过 GeoJson方式加载点图层（SymbolLayer） 和 InfoWindow图层</p></li><li><p>塑造数据源：FeatureCollection （AsnyTask中）</p><ul><li><p>geoJson文件塑造成String方式，通过FeatureCollection.fromJson(geoJson)获取FeatureCollection;</p></li><li><p>赋值给所有Feature, seleted字段为 false（弹出窗口的状态）</p></li></ul></li><li><p>设置数据源： 设置Source Image(Marker图标) MarkerLayer InfoWindowLayer</p><ul><li><p>设置Source<br>  GeoJsonSource source = new GeoJsonSource(geojsonSourceId, featureCollection);<br>  mapboxMap.addSource(source);</p></li><li><p>Image(Marker图标)<br>  Bitmap icon = BitmapFactory.decodeResource(this.getResources(), R.drawable.red_marker);<br>  mapboxMap.addImage(MARKER_IMAGE_ID, icon);</p></li><li><p>mapboxMap.addLayer(new SymbolLayer(MARKER_LAYER_ID, geojsonSourceId)<br>  .withProperties(</p><pre><code>- iconImage(MARKER_IMAGE_ID),//用于绘制图像背景的sprite图像的名称。- iconAllowOverlap(true)//如果为 true, 则图标将可见, 即使它与其他以前绘制的符号碰撞。</code></pre><p>  ));</p></li></ul></li></ul><pre><code>- InfoWindowLayer</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mapboxMap.addLayer(new SymbolLayer(CALLOUT_LAYER_ID, geojsonSourceId)</span><br><span class="line">.withProperties(</span><br><span class="line">  iconImage(&quot;&#123;name&#125;&quot;),&#x2F;&#x2F;用于绘制图像背景的sprite图像的名称。</span><br><span class="line">  iconAnchor(ICON_ANCHOR_BOTTOM), &#x2F;&#x2F;图标的锚点（左右上下、左上、右上、左下、右下 ）    </span><br><span class="line">  iconAllowOverlap(true), &#x2F;&#x2F;如果为 true, 则图标将可见, 即使它与其他以前绘制的符号碰撞      </span><br><span class="line">  iconOffset(new Float[] &#123;-2f, -25f&#125;)&#x2F;&#x2F;设置图标距其定位点的偏移距离 正值表示右下, 负值表示左和上。当与iconRotate(java.lang.Float)组合时, &#x2F;&#x2F;偏移量旋转的方向是向上的。第一个参数表示左（负数）右（正数）、第一个参数表示上（负数）下（正数）</span><br><span class="line">)</span><br><span class="line">.withFilter(eq((get(PROPERTY_SELECTED)), literal(true))));&#x2F;&#x2F;设置过滤器 当geojson中属性为true的Source显示</span><br></pre></td></tr></table></figure><ul><li><p>dds-GeoJsonClusteringActivity 点聚合功能</p><ul><li>问题：我们的地图不支持聚合，mapbox的地图支持，Feture如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapbox： &#123;&quot;geometry&quot;:&#123;&quot;coordinates&quot;:[-74.02587890625,-37.23470197166816],&quot;type&quot;:&quot;Point&quot;&#125;,&quot;id&quot;:&quot;&quot;,&quot;properties&quot;:&#123;&quot;point_count&quot;:7,&quot;cluster&quot;:true&#125;,&quot;type&quot;:&quot;Feature&quot;&#125;</span><br><span class="line">mapscloud:&#123;&quot;geometry&quot;:&#123;&quot;coordinates&quot;:[-68.26904296875,-38.28131307922966],&quot;type&quot;:&quot;Point&quot;&#125;,&quot;id&quot;:&quot;&quot;,&quot;properties&quot;:&#123;&quot;time&quot;:1506387869490,&quot;id&quot;:&quot;us2000avl1&quot;,&quot;felt&quot;:4,&quot;tsunami&quot;:0,&quot;mag&quot;:4.099999904632568&#125;,&quot;type&quot;:&quot;Feature&quot;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>PropertyValue<T>获取方式通过： PropertyFactory 为图层构造paint/layout属性</p></li></ul><ul><li>Expression 表达式 （把各种属性 类型转化为表达式）</li></ul><table><thead><tr><th align="left">方法</th><th align="left">参数说明</th><th align="left">绘制值格式</th></tr></thead><tbody><tr><td align="left">literal()</td><td align="left">参数：1个 Number String boolean Object Object[]</td><td align="left">返回：转换为表达式</td></tr><tr><td align="left">color()</td><td align="left">参数：1个 int (Color.GREEN)</td><td align="left">返回：表达式  fillColor(color(Color.GREEN))</td></tr><tr><td align="left">rgb()</td><td align="left">参数：3个 Expression(红绿蓝表达式) Number</td><td align="left">返回：表达式  fillColor(rgb(literal(255.0f), literal(255.0f),literal(255.0f)))</td></tr><tr><td align="left">rgba()</td><td align="left">参数：4个 表达式 Number</td><td align="left">返回：Expression    fillColor(rgb(255.0f, 255.0f, 255.0f, 1.0f))</td></tr><tr><td align="left">toRgba</td><td align="left">参数：1个 颜色表达式</td><td align="left">返回：Expression 返回一个包含输入颜色的红、绿、蓝和alpha组件的四元素数组，按顺序排列</td></tr><tr><td align="left">eq</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、boolean、String、Number</td><td align="left">返回：第一参数和第二个参数相同返回 true 否则相反</td></tr><tr><td align="left">neq</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、boolean、String、Number</td><td align="left">返回：第一参数和第二个参数不相同返回 true 否则相反</td></tr><tr><td align="left">gt</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、String、Number</td><td align="left">返回：如果第一个大于第二个输入，则返回true，否则返回false   &gt;</td></tr><tr><td align="left">lt</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、String、Number</td><td align="left">返回：如果第一个输入小于第二个输入，则返回true，否则返回false  &lt;</td></tr><tr><td align="left">gte</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、String、Number</td><td align="left">返回：如果第一个输入大于或等于第二个输入，则返回true，否则返回false  &gt;=</td></tr><tr><td align="left">lte</td><td align="left">参数：2个 第一个参数：表达式  第二个参数：表达式、String、Number</td><td align="left">返回：如果第一个输入小于或等于第二个输入，则返回true，否则返回false  &lt;=</td></tr><tr><td align="left">all</td><td align="left">参数：n个 Expression</td><td align="left">返回：如果所有输入都为true，则返回true，否则返回false</td></tr><tr><td align="left">any</td><td align="left">参数：n个 Expression</td><td align="left">返回：如果任何输入为“true”，则返回“true”，否则返回“false”</td></tr><tr><td align="left">not</td><td align="left">参数：1个 Expression/boolean</td><td align="left">返回：逻辑的否定。如果输入为“false”，返回“true”;如果输入为“true”，返回“false”</td></tr><tr><td align="left">switchCase</td><td align="left">参数：n个 Expression 最少1个</td><td align="left">返回：选择对应的测试条件为true的第一个输出       iconSize( switchCase( get(KEY_TO_BOOLEAN), literal(3.0f), get(KEY_TO_OTHER_BOOLEAN), literal(5.0f) literal(1.0f) // default value    ))</td></tr><tr><td align="left">match</td><td align="left">参数：n个 Expression 最少2个</td><td align="left">返回：选择标签值与输入值匹配的输出，如果没有找到匹配，则选择回退值 match(get(“keyToValue”), literal(1), rgba(255, 0, 0, 1.0f),literal(2), rgba(0, 0, 255.0f, 1.0f),rgba(0.0f, 255.0f, 0.0f, 1.0f));</td></tr><tr><td align="left">coalesce</td><td align="left">参数：n个 Expression</td><td align="left">返回：依次计算每个表达式，直到获得第一个非空值，并返回该值</td></tr><tr><td align="left">properties</td><td align="left">参数：Void</td><td align="left">返回：获取properties Expression对象symbolLayer.setProperties(textField(get(“key-to-value”, properties()))));</td></tr><tr><td align="left">geometryType</td><td align="left">参数：Void</td><td align="left">返回：获取feature的几何类型Expression:点、多点、线字符串、多线字符串、多边形、多多边形 textField(concat(get(“key-to-value”), literal(“ “), geometryType())</td></tr><tr><td align="left">id()</td><td align="left">参数：Void</td><td align="left">返回：获取feature的id(如果它有) symbolLayer.setProperties(textField(id()));</td></tr><tr><td align="left">heatmapDensity()</td><td align="left">参数：Void</td><td align="left">返回：获取热图层中像素的核密度估计，这是一个相对测量特定像素周围有多少数据点。只能在“heatmap color”属性中使用 HeatmapLayer layer = new HeatmapLayer(“layer-id”, “source-id”); layer.setProperties( heatmapColor(interpolate(linear(), heatmapDensity(),  literal(0), rgba(33, 102, 172, 0),  literal(0.2), rgb(103, 169, 207), literal(0.4), rgb(209, 229, 240),  literal(0.6), rgb(253, 219, 199), literal(0.8), rgb(239, 138, 98),  literal(1), rgb(178, 24, 43)  ) )</td></tr><tr><td align="left">at</td><td align="left">参数：2个 第一个参数：数组中的index Expression/Number   第二个参数：array数组 Expression</td><td align="left">返回：从数组中检索某一项</td></tr><tr><td align="left">get</td><td align="left">参数：1个 input Expression/String</td><td align="left">返回：从当前feature的属性中检索属性值，或来自另一个对象，如果提供了第二个参数。如果缺少所请求的属性，则返回null（Expression）</td></tr><tr><td align="left">get</td><td align="left">参数：2个 第一个参数：a property value key  String/Expression   第二个参数：an expression object(Expression)</td><td align="left">返回：从当前object的属性中检索属性值</td></tr><tr><td align="left">has</td><td align="left">参数：1个 Expression/String key</td><td align="left">返回：测试当前特性属性中是否存在属性值</td></tr><tr><td align="left">has</td><td align="left">参数：2个 第一个参数：a property value key  String/Expression   第二个参数：an expression object(Expression)</td><td align="left">返回：从当前object的属性中检索是否存在属性值</td></tr><tr><td align="left">length</td><td align="left">参数：1个 an expression object or expression string</td><td align="left">返回：获取数组或字符串的长度</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>ln2()   pi<br> e()   sum  product乘积  subtract 0-某个数  division除   mod 将第一个输入的整数除以第二个输入后的余数  pow(x,y)x的y次方  sqrt(x) x的平方<br> log10  ln log2 ….<br> toString<br> toArray()<br> zoom()  获取当前缩放级别<br> stop()  产生一个停止值<br> step()  阶段性变化  通过计算由对定义的分段常数函数，得到离散的、阶跃的结果<br> interpolate() 内插 通过在输入和输出值(\“stop”)之间插入，生成连续的、<br> linear() 在小于和大于输入的两个停止点之间进行线性插值<br> exponential() 在小于和大于输入的点之间进行指数插值<br> cubicBezier() 使用给定控制点定义的三次贝塞尔曲线插值</p><h2 id="自己总结："><a href="#自己总结：" class="headerlink" title="自己总结："></a>自己总结：</h2><h4 id="添加图层的流程"><a href="#添加图层的流程" class="headerlink" title="添加图层的流程"></a>添加图层的流程</h4><ul><li>构建geometry （点 线 面、多点 多线 多面），多个构建geometry为GeometryCollection</li><li>构建Feature</li><li>构建Source  (sourceId,feature）（图像、自定义Geometry、栅格dem、栅格、矢量、不知道）</li><li>source添加到mapbox中</li><li>创建Layer (layerId,sourceId)</li><li>layer添加到mapbox中</li></ul><h4 id="Source-Layer"><a href="#Source-Layer" class="headerlink" title="Source Layer"></a>Source Layer</h4><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">CustomGeometrySource</td><td align="left">自定义矢量源，允许使用FeatureCollections</td></tr><tr><td align="left">ImageSource</td><td align="left">图像源，允许在地图上显示地理参考光栅图像(地理参考图像随着用户缩放和旋转地图而缩放和旋转。光栅图像内容的地理位置，随“latlngquad”提供，可以是非轴对齐的)</td></tr><tr><td align="left">GeoJsonSource</td><td align="left">geojson源，允许使用来自json的featurecollections。</td></tr><tr><td align="left">RasterDemSource</td><td align="left">光栅DEM源。当前仅支持Mapbox Terrain RGB（mapbox://mapbox.terrain-rgb）</td></tr><tr><td align="left">RasterSource</td><td align="left">光栅源，允许使用光栅平铺作为源。</td></tr><tr><td align="left">VectorSource</td><td align="left">矢量源，允许使用矢量块。</td></tr><tr><td align="left">UnknownSource</td><td align="left">An unknown type of source</td></tr><tr><td align="left">BackgroundLayer</td><td align="left">地图的背景色或图案 (是地图的背景色)</td></tr><tr><td align="left">CircleLayer</td><td align="left">A filled circle.（不会随地图缩放而缩放）</td></tr><tr><td align="left">CustomLayer</td><td align="left">自定义层。实验特性。不要使用。</td></tr><tr><td align="left">FillExtrusionLayer</td><td align="left">一个挤出的（三维）多边形。</td></tr><tr><td align="left">FillLayer</td><td align="left">具有可选边界的填充多边形。</td></tr><tr><td align="left">HeatmapLayer</td><td align="left">热图图层</td></tr><tr><td align="left">HillshadeLayer</td><td align="left">基于dem数据的客户端山体阴影可视化。目前，该实现仅支持mapbox terrain rgb和 mapzen terrarium tiles。</td></tr><tr><td align="left">LineLayer</td><td align="left">线图层</td></tr><tr><td align="left">RasterLayer</td><td align="left">栅格图层</td></tr><tr><td align="left">symbolLayer</td><td align="left">图标或文本标签图层</td></tr><tr><td align="left">UnknownLayer</td><td align="left"></td></tr><tr><td align="left">LatLngQuad</td><td align="left">不规则的多边形</td></tr><tr><td align="left">LatLngBound</td><td align="left">矩形</td></tr><tr><td align="left">PropertyFactory</td><td align="left">构造图层的绘制/布局特性</td></tr></tbody></table><ul><li><p>通用属性 </p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">visibility</td><td align="left">可见度</td></tr><tr><td align="left">Opacity</td><td align="left">透明度</td></tr><tr><td align="left">Gradient</td><td align="left">渐变</td></tr><tr><td align="left">Halo</td><td align="left">环状光晕</td></tr><tr><td align="left">Translate</td><td align="left">根据锚定的中心，上下左偏移</td></tr><tr><td align="left">TranslateAnchor</td><td align="left">锚点</td></tr><tr><td align="left">Blur</td><td align="left">模糊</td></tr><tr><td align="left">Alignment 排列方向</td><td align="left"></td></tr><tr><td align="left">textOpacity</td><td align="left"></td></tr><tr><td align="left">textColor</td><td align="left"></td></tr><tr><td align="left">textHaloColor</td><td align="left">文本光晕的颜色，这有助于它从背景中脱颖而出。</td></tr><tr><td align="left">textHaloWidth</td><td align="left"></td></tr><tr><td align="left">textHaloBlur 光环向外逐渐消失的距离</td><td align="left"></td></tr><tr><td align="left">textTranslate</td><td align="left"></td></tr><tr><td align="left">textTranslateAnchor</td><td align="left"></td></tr><tr><td align="left">textPitchAlignment</td><td align="left"></td></tr><tr><td align="left">textRotationAlignment</td><td align="left">与{@link property.symbol_placement}结合使用，确定形成文本的各个标志符号的旋转行为。</td></tr><tr><td align="left">textField</td><td align="left">用于文本标签的值。如果提供了纯“string”，则将其视为具有默认/继承格式选项的“formatted”。</td></tr><tr><td align="left">textFont</td><td align="left"></td></tr><tr><td align="left">textSize</td><td align="left"></td></tr><tr><td align="left">textMaxWidth</td><td align="left"></td></tr><tr><td align="left">textLineHeight</td><td align="left">用于显示文本的字体堆栈。多行文本的文本前导值。</td></tr><tr><td align="left">textLetterSpacing</td><td align="left">文本跟踪量。</td></tr><tr><td align="left">textJustify</td><td align="left">文本对齐选项。</td></tr><tr><td align="left">textRadialOffset</td><td align="left">文本在符号锚定方向上的径向偏移。与不支持二维{@link propertyfactory{@textfariableanchor}的{@link propertyfactory}结合使用时非常有用。</td></tr><tr><td align="left">textVariableAnchor</td><td align="left">为了增加在地图上放置高优先级标签的机会，您可以提供一个{@ Link属性.TrimeActudi}位置的数组：呈现将尝试在每个位置上放置标签，然后再移动到下一个标签。使用“text justify:auto”根据定位点位置选择对齐方式。要应用偏移量，请使用{@link propertyfactory{textradialoffset}，而不是二维{@link propertyfactory{textoffset}。</td></tr><tr><td align="left">textAnchor</td><td align="left"></td></tr><tr><td align="left">textMaxAngle</td><td align="left">相邻字符之间的最大角度变化。</td></tr><tr><td align="left">textRotate</td><td align="left">顺时针旋转文本。</td></tr><tr><td align="left">textPadding</td><td align="left"></td></tr><tr><td align="left">textKeepUpright</td><td align="left">如果为true，则可以垂直翻转文本以防止其被颠倒。</td></tr><tr><td align="left">textTransform</td><td align="left">指定如何大写文本，类似于css{@link propertyfactory\texttransform}属性</td></tr><tr><td align="left">textOffset</td><td align="left">文本与其定位点的偏移距离。正值表示向右和向下，负值表示向左和向上。</td></tr><tr><td align="left">textAllowOverlap</td><td align="left">如果为true，则文本将可见，即使它与以前绘制的其他符号冲突。</td></tr><tr><td align="left">textIgnorePlacement</td><td align="left">如果是真的，即使与文本发生冲突，也可以看到其他符号。</td></tr><tr><td align="left">textOptional</td><td align="left">如果为true，则当文本与其他符号冲突且图标不冲突时，将显示图标而不显示相应的文本。</td></tr></tbody></table></li><li><p>点属性</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">iconOpacity</td><td align="left"></td></tr><tr><td align="left">iconColor</td><td align="left"></td></tr><tr><td align="left">iconHaloColor</td><td align="left">图标光环的颜色。图标光晕只能与SDF图标一起使用。</td></tr><tr><td align="left">iconHaloWidth</td><td align="left">光晕到图标轮廓的距离。</td></tr><tr><td align="left">iconHaloBlur</td><td align="left">把光环向外面褪去</td></tr><tr><td align="left">iconTranslate</td><td align="left">图标锚定从其原始位置移动的距离。正值表示向右和向下，负值表示向左和向上。</td></tr><tr><td align="left">iconTranslateAnchor</td><td align="left">控制{@link propertyfactory icontranslate}的引用框架。</td></tr><tr><td align="left">iconAllowOverlap</td><td align="left">如果是真的，即使它与其他先兆Drawn   (不管地图如何缩放 其他图标点是否遮盖 此图标时刻都显示)</td></tr><tr><td align="left">iconIgnorePlacement</td><td align="left">如果是真的，即使符号与图标碰撞，也可以看到其他符号。</td></tr><tr><td align="left">iconOptional</td><td align="left">如果真的是这样，文字将显示没有对应图标的图标，而图标与其他Symbols没有对应图案。</td></tr><tr><td align="left">iconRotationAlignment</td><td align="left">结合{@link property.symbol_placement}，确定图标的旋转行为。</td></tr><tr><td align="left">iconSize</td><td align="left">按提供的因子缩放图标的原始大小，图像的新像素将是原像素的六倍乘以{@link PropertyFactory#iconSize} 1是原像素的六倍；图像的六倍</td></tr><tr><td align="left">iconTextFit</td><td align="left">缩放图标以适应相关文本。</td></tr><tr><td align="left">iconTextFitPadding</td><td align="left">按顺时针顺序添加到由{@link property.icon_text_fit}确定的维度的附加区域的大小：top、right、bottom、left。</td></tr><tr><td align="left">iconImage</td><td align="left">sprite中用于绘制图像背景的图像的名称</td></tr><tr><td align="left">iconRotate</td><td align="left">顺时针旋转图标</td></tr><tr><td align="left">iconPadding</td><td align="left"></td></tr><tr><td align="left">iconKeepUpright</td><td align="left">如果为true，则可以翻转图标以防止其被颠倒渲染。</td></tr><tr><td align="left">iconOffset</td><td align="left">图标与其锚定的偏移距离。正值表示向右和向下，负值表示向左和向上。每个分量乘以{@link   propertyfactory iconsize}的值，以获得与密度无关的像素的最终偏移量。当与{@ Link PrimePrimeWorksIon Simult}组合时，偏移将如同旋转方向上升一样。</td></tr><tr><td align="left">iconAnchor</td><td align="left">最靠近锚定的图标的一部分。</td></tr><tr><td align="left">iconPitchAlignment</td><td align="left">当地图倾斜时图标的方向。</td></tr></tbody></table></li></ul><ul><li><p>线属性</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">lineOpacity</td><td align="left"></td></tr><tr><td align="left">lineColor</td><td align="left"></td></tr><tr><td align="left">lineTranslate</td><td align="left">几何体的偏移量。值是[x，y]，其中负数分别表示左和上。</td></tr><tr><td align="left">lineTranslateAnchor</td><td align="left">控制{@link propertyfactory linetranslate}的引用框架。</td></tr><tr><td align="left">lineWidth</td><td align="left"></td></tr><tr><td align="left">lineGapWidth</td><td align="left">在线的实际路径外绘制线框。值指示内部间隙的宽度。</td></tr><tr><td align="left">lineOffset</td><td align="left">线的偏移量。对于线性特征，正值相对于直线的方向使直线向右偏移，负值相对于直线的方向向左偏移。对于多边形特征，正值将导致插入，负值将导致开始。</td></tr><tr><td align="left">lineBlur</td><td align="left">应用于线条的模糊，以与密度无关的像素为单位。</td></tr><tr><td align="left">lineDasharray</td><td align="left">虚线的间隔设置  new Float[] {10f, 4f}   10f 是实线段长度； 4f是间隔长度。指定形成虚线图案的交替虚线和间隙的长度。这些长度稍后将按线宽缩放。若要将虚线长度转换为与密度无关的像素，请将该长度乘以当前线宽。请注意，指定了“linemetrics:true”的geojson源不会将虚线呈现为预期的比例。还要注意，缩放相关表达式将仅在整数缩放级别计算。</td></tr><tr><td align="left">linePattern</td><td align="left">用于绘制图像线的sprite中的图像的名称。对于无缝图案，图像宽度必须是2的系数（2、4、8、…、512）。请注意，缩放相关表达式将仅在整数缩放级别计算。</td></tr><tr><td align="left">lineGradient</td><td align="left">定义用于为线要素上色的渐变。只能用于GeJSON源，指定“LeeMeimTrime:Trime’”。</td></tr><tr><td align="left">lineCap</td><td align="left">线的两端形状 （圆形round  正方的SQUARE BUTT 没看出区别）</td></tr><tr><td align="left">lineJoin</td><td align="left">是线条的转弯处的形状是什么(圆形round  正方的MITER  中间过渡折线BEVEL)</td></tr><tr><td align="left">lineMiterLimit</td><td align="left">用于自动将斜接转换为斜接以获取锐角。</td></tr><tr><td align="left">lineRoundLimit</td><td align="left">用于自动将圆连接转换为浅角度的斜接连接。</td></tr><tr><td align="left">symbolPlacement</td><td align="left">相对于其几何图形的标签放置。</td></tr><tr><td align="left">symbolSpacing</td><td align="left">两个符号锚定之间的距离。</td></tr><tr><td align="left">symbolAvoidEdges</td><td align="left">如果为true，则符号不会交叉平铺边缘以避免相互碰撞。建议在矢量平铺中没有足够填充以防止冲突的层中使用，或者如果它是放置在线符号层之后的点符号层。</td></tr><tr><td align="left">symbolSortKey</td><td align="left">基于此值按升序排列要素。具有较高排序键的要素重叠时，将显示在具有较低排序键的要素上方。放置时，排序键较低的功能将优先于其他功能</td></tr><tr><td align="left">symbolZOrder</td><td align="left">控制同一层中重叠符号的呈现顺序</td></tr></tbody></table></li><li><p>面属性</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillAntialias</td><td align="left">填充是否应抗锯齿。</td></tr><tr><td align="left">fillOpacity</td><td align="left"></td></tr><tr><td align="left">fillColor</td><td align="left"></td></tr><tr><td align="left">fillOutlineColor</td><td align="left"></td></tr><tr><td align="left">fillTranslate</td><td align="left">几何体的偏移量。值是[x，y]，其中负数分别表示左和上。</td></tr><tr><td align="left">fillTranslateAnchor</td><td align="left">控制{@link propertyfactory filltranslate}的引用框架。</td></tr><tr><td align="left">fillPattern</td><td align="left">精灵中用于绘制图像填充的图像的名称。对于无缝图案，图像宽度和高度必须是2的系数（2、4、8、…、512）。请注意，缩放相关表达式将仅在整数缩放级别计算</td></tr><tr><td align="left">circleRadius</td><td align="left"></td></tr><tr><td align="left">circleColor</td><td align="left"></td></tr><tr><td align="left">circleBlur</td><td align="left">等于模糊了圆圈。1模糊圆，因此只有中心点是完全不透明的。</td></tr><tr><td align="left">circleOpacity</td><td align="left"></td></tr><tr><td align="left">circleTranslate</td><td align="left"></td></tr><tr><td align="left">circleTranslateAnchor</td><td align="left"></td></tr><tr><td align="left">circlePitchScale</td><td align="left">控制地图倾斜时圆的缩放行为。 （圆圈与地图平面对齐。 圆与视区平面对齐。）</td></tr><tr><td align="left">circlePitchAlignment</td><td align="left">地图倾斜时圆的方向。 （圆圈与地图平面对齐。 圆与视区平面对齐。）</td></tr><tr><td align="left">circleStrokeWidth</td><td align="left"></td></tr><tr><td align="left">circleStrokeColor</td><td align="left"></td></tr><tr><td align="left">circleStrokeOpacity</td><td align="left"></td></tr><tr><td align="left">heatmapRadius</td><td align="left">密度无关像素中一个热图点的影响半径。增加该值会使热图更平滑，但细节较少。</td></tr><tr><td align="left">heatmapWeight</td><td align="left">测量单个点对热图贡献的程度。值为10相当于在同一个点上有10个权重1。与群集结合时特别有用。</td></tr><tr><td align="left">heatmapIntensity</td><td align="left">类似于{@link propertyfactory heatmapweight}，但全局控制heatmap的强度。主要用于根据缩放级别调整热图。</td></tr><tr><td align="left">heatmapColor</td><td align="left"></td></tr><tr><td align="left">heatmapOpacity</td><td align="left"></td></tr><tr><td align="left">fillExtrusionOpacity</td><td align="left"></td></tr><tr><td align="left">fillExtrusionColor</td><td align="left"></td></tr><tr><td align="left">fillExtrusionTranslate</td><td align="left"></td></tr><tr><td align="left">fillExtrusionTranslateAnchor</td><td align="left"></td></tr><tr><td align="left">fillExtrusionPattern</td><td align="left"></td></tr><tr><td align="left">fillExtrusionHeight</td><td align="left">挤出此层的高度。</td></tr><tr><td align="left">fillExtrusionBase</td><td align="left">挤出此层底部的高度。必须小于或等于{@Link PropertyFactory FillExtrusionHeight}</td></tr><tr><td align="left">fillExtrusionVerticalGradient</td><td align="left">是否对填充拉伸层的边应用垂直渐变。如果为真，则后面的边将稍微暗一点。</td></tr><tr><td align="left">rasterOpacity</td><td align="left"></td></tr><tr><td align="left">rasterHueRotate</td><td align="left">围绕色轮旋转色调</td></tr><tr><td align="left">rasterBrightnessMin</td><td align="left">增加或降低图像的亮度。该值是最小亮度。</td></tr><tr><td align="left">rasterBrightnessMax</td><td align="left">增加或降低图像的亮度。该值是最大亮度</td></tr><tr><td align="left">rasterSaturation</td><td align="left">增加或减少图像的饱和度</td></tr><tr><td align="left">rasterContrast</td><td align="left">增加或减少图像的对比度</td></tr><tr><td align="left">rasterResampling</td><td align="left">用于过缩放的重采样/插值方法，也称为纹理放大过滤器</td></tr><tr><td align="left">rasterFadeDuration</td><td align="left">添加新平铺时淡入淡出持续时间</td></tr><tr><td align="left">hillshadeIlluminationDirection</td><td align="left">山体阴影的光源的方向 ， 如果{@link property.hillshade\u illumination\u anchor}设置为“viewport”，则用于生成以0为视区顶部的山体阴影的光源的方向；如果{@link property.hillshade\u illumination\u anchor}设置为“map”，则为正北。</td></tr><tr><td align="left">hillshadeIlluminationAnchor</td><td align="left">地图旋转时光源的方向。</td></tr><tr><td align="left">hillshadeExaggeration</td><td align="left">山体的强度</td></tr><tr><td align="left">hillshadeShadowColor</td><td align="left">远离光源的区域的阴影颜色。</td></tr><tr><td align="left">hillshadeHighlightColor</td><td align="left">面向光源的区域的着色颜色。</td></tr><tr><td align="left">hillshadeAccentColor</td><td align="left">阴影颜色用来突出崎岖的地形，如陡峭的悬崖和峡谷。</td></tr><tr><td align="left">backgroundColor</td><td align="left">绘制背景的颜色</td></tr><tr><td align="left">backgroundPattern</td><td align="left">用于绘制图像背景的sprite中的图像的名称。对于无缝图案，图像宽度和高度必须是2的系数（2、4、8、…、512）。请注意，缩放相关表达式将仅在整数缩放级别计算。</td></tr><tr><td align="left">backgroundOpacity</td><td align="left"></td></tr><tr><td align="left">Expression</td><td align="left"></td></tr><tr><td align="left">MapView</td><td align="left"></td></tr><tr><td align="left">addOnStyleImageMissingListener</td><td align="left">设置在缺少图标ID时调用的回调。  mapboxMap.setLatLngBoundsForCameraTarget(LAKE_BOUNDS);</td></tr></tbody></table></li></ul><h4 id="WoldMap-优化"><a href="#WoldMap-优化" class="headerlink" title="WoldMap 优化"></a>WoldMap 优化</h4><ul><li>经纬网 上下左右多画一屏幕</li><li>九宫格  显示与否 可以根据  设置属性 no  Visible不可以设置表达式 只接受String</li><li>地图加载慢原因： </li><li>MapboxMapOptions 的构建<ul><li>MapView.onCreate地图加载进来后闪一下 重新加载问题 （&lt;=7级 就会闪一下，&gt;7级不会闪）<ul><li>在onMapReady中操作一下Layer，也不会闪了</li><li>根源是样式文件问题：<ul><li>1.”<a href="http://202.107.245.52:10430/v1.0/styles/Global_mbtiles/style.json&quot;" target="_blank" rel="noopener">http://202.107.245.52:10430/v1.0/styles/Global_mbtiles/style.json&quot;</a>; 样式就会闪一下</li><li>2.”<a href="http://119.3.195.167:10430/v1.0/styles/CASmap_style_D2_v4_3D_1/style.json&quot;" target="_blank" rel="noopener">http://119.3.195.167:10430/v1.0/styles/CASmap_style_D2_v4_3D_1/style.json&quot;</a>; 样式就不会闪；</li></ul></li></ul></li></ul></li></ul><ul><li><p>二维地图</p><ul><li>icon_add_polyline</li><li>icon_map_latlongrid</li><li>icon_map_jgg</li><li>icon_interaction</li></ul></li><li><p>二维小工具</p><ul><li>icon_altitude_calculation</li><li>icon_profile_overview</li><li>icon_positive_calculation </li><li>icon_Inverse_calculation</li><li>icon_snapshot_share</li><li>icon_sheet_search</li><li>icon_annotation_freehand_comment</li><li>icon_annotation_comment</li><li>icon_bbox_elevation</li><li>icon_single_elevation</li><li>icon_sightline_analyse</li><li>icon_beidou_info</li><li>icon_location</li><li>icon_fence</li></ul></li><li><p>专题地图</p><ul><li>icon_theme_list</li><li>icon_theme_net_load</li><li>icon_theme_local_load</li><li>icon_theme_switch</li><li>icon_theme_opacity</li><li>icon_theme_manage</li><li>icon_theme_word_search</li><li>icon_theme_fenlei_search</li><li>icon_theme_shiye_search</li><li>icon_theme_legend_show</li><li>icon_theme_detaildata_show</li></ul></li><li><p>地名搜素</p><ul><li>icon_search_search</li><li>icon_search_area</li><li>icon_search_surround</li><li>icon_search_fenlei</li><li>icon_search_offline_search</li></ul></li><li><p>信息采集</p></li><li><p>坐标转换</p><ul><li>icon_coord_positive_operation</li><li>icon_coord_inverse_operation</li><li>icon_positive_gauss_cal</li><li>Inverse_gauss_cal</li><li>icon_coord_trans_ecef_operation</li><li>icon_coord_ecef_trans_operation</li><li>icon_coord_trans_ellipsoid_operation</li></ul></li><li><p>三维地图</p><ul><li>icon_globe_image</li><li>icon_globe_dem</li><li>icon_globe_annotation</li><li>icon_globe_event</li><li>icon_globe_operate</li><li>icon_globe_layers</li><li>icon_globe_point</li><li>icon_globe_line</li><li>icon_globe_polygon</li><li>icon_globe_model</li><li>icon_globe_tilesy</li><li>icon_globe_theme</li><li>icon_globe_camera</li><li>icon_globe_info</li></ul></li><li><p>三维地图小工具</p><ul><li>icon_globe_tolocation</li><li>icon_globe_leida</li><li>icon_globe_label</li></ul></li></ul><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><p>MapFragment  newInstance(MapboxMapOptions)<br>用MapView  MapView(Context, MapboxMapOptions)<br>用XML添加映射，则可以使用自定义XML标记应用这些选项。</p><p>##四、Mapbox和STMapView对比</p><p>STMapView<br>isEnableLimitBox 判断是否启用范围限制框<br>setEnableLimitBox 设置启用限制框<br>getLatitudeSpan 获取纬度范围<br>getLongitudeSpan 获取经度范围<br>getBoundingBox 获取外接矩形框<br>getBoundingBox 获取指定宽高的外接矩形框<br>getScreenRect 获取当前屏幕区域坐标（旋转后的）<br>setMapOrientation 设置地图方向<br>setScrollableAreaLimit 设置移动范围外接矩形框，地图将不能超出这个范围<br>zoomInFixing以固定点为中心放大<br>zoomOutFixing以固定点为中心缩小<br>zoomToSpan缩放到指定范围</p><ul><li><p>跳转  动画跳转<br> 跳转中心点  setMapCenter setCenter<br> 跳转缩放级别<br> 跳转中心点和缩放级别<br> 跳转到矩形框  getScreenRect</p></li><li><p>缩放<br> 缩放到外接矩形框<br> 缩放到固定点（放大 缩小）<br> 缩放到指定范围</p></li></ul><p>getScreenRect<br>setMapCenter<br>adjustZoomLevel<br>setZoomLevel<br>zoomToBoundingBox<br>getZoomlevelByBoundingBox<br>getZoomLevel<br>getMinZoomLevel<br>getMaxZoomLevel<br>canZoomIn<br>getMapCenter<br>isNightMode<br>scrollTo（xy）<br>getMapBoundingBox</p><p>animateToSpan<br>animateTo<br>zoomToSpan<br>scrollBy<br>setCenter<br>setZoom</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mapbox-Demo-学习记录&quot;&gt;&lt;a href=&quot;#Mapbox-Demo-学习记录&quot; class=&quot;headerlink&quot; title=&quot;Mapbox Demo 学习记录&quot;&gt;&lt;/a&gt;Mapbox Demo 学习记录&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FBS_LGYS</title>
    <link href="http://yoursite.com/2020/06/03/FBS_LGYS/"/>
    <id>http://yoursite.com/2020/06/03/FBS_LGYS/</id>
    <published>2020-06-03T02:33:03.061Z</published>
    <updated>2020-06-02T07:28:17.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统设计总鉴"><a href="#分布式系统设计总鉴" class="headerlink" title="分布式系统设计总鉴"></a>分布式系统设计总鉴</h2><h3 id="SOA面向服务架构"><a href="#SOA面向服务架构" class="headerlink" title="SOA面向服务架构"></a>SOA面向服务架构</h3><ul><li>面向服务设计范式的设计原则<ul><li>标准化服务契约：服务遵循相同的契约设计标准。</li><li>服务松散耦合：服务契约对服务消费者松耦合，服务之间松耦合。</li><li>服务抽象：服务契约仅包含必要信息，并且关于服务的信息局限为服务契约中发布的信息。</li><li>服务可重用性：服务可作为重用资源。</li><li>服务自治：服务对其底层运行时执行环境有很大的控制权。</li><li>服务无状态性：服务无状态保证了服务部署的横向扩展性。</li><li>服务可发现性：服务可通过描述性元数据有效发现并解释服务。</li><li>服务可组合性：可以通过组合叠合原子服务形成复杂上层业务服务。</li></ul></li><li>SOA架构的基本原则是降低服务间的耦合度，使服务可以类似于模块或组件的形式进行配合使用。<ul><li>模块化服务使用</li><li>服务间低耦合</li><li>类似于oauth的方式使用服务，使服务间通过网络进行调用</li></ul></li><li>SOA与微服务的区别<ul><li>SOA面向大块业务逻辑，微服务属于单独任务或小块业务逻辑</li><li>SOA着重于中央管理，微服务着重分散管理</li><li>SOA确保能够交互操作，微服务确保执行新功能、快速拓展开发团队</li></ul></li></ul><h3 id="kubernetes（K8S）"><a href="#kubernetes（K8S）" class="headerlink" title="kubernetes（K8S）"></a>kubernetes（K8S）</h3><ul><li>企业级微服务框架</li><li>node是集群中的工作节点，运行真正的应用程序，在node上k8s管理的最小运行单元是Pod。<ul><li>node上运行着k8s以及相关服务进程，这些服务进程负责pod的创建、启动、监控、重启、销毁、以及实现软件模式的负载均衡</li></ul></li><li>Pod是k8s的最基本的操作单元，包含一个或多个紧密相关的容器，一个Pod可以被一个容器换的环境看做应用层的“逻辑宿主机”</li><li>Pod在k8s的世界中，每一个pod会分配一个ip地址，但这个ip地址会随着pod的销毁而消失，这就有一个问题了，如果一组pod组成的一个集群来提供服务，那么如何来方位它呢？通过Services</li><li>一个services可以看作一组提供相同服务的pod的对外访问接口</li></ul><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li>Nginx是一个代理服务器的角色，为了避免单独一个服务器压力过大，而将来自不同用户的请求发送给不同的服务器，形成1对多的关系的一种技术</li><li>Nginx分配方式<ul><li>权重方式（自定义），轮询进行分配，通过权重提高服务器轮询的几率</li><li>根据ip分配方式，按照基于客户端的ip的分配方式，保障相同客户端的请求一直发送给相同的服务器，可以保证session会话</li><li>最少连接方式</li><li>最快响应方式</li><li>根据url分配（自定义），可以在指定url请求某一台服务器，例如下载某资源时会去同一台服务器去下载，这样会提高利用率</li></ul></li><li>在Nginx中如果有某一台服务器宕机了，那么在Nginx轮询发现后，会将改服务器剔除</li></ul><h3 id="Spring-Boot-与-Spring-Cloud"><a href="#Spring-Boot-与-Spring-Cloud" class="headerlink" title="Spring Boot 与 Spring Cloud"></a>Spring Boot 与 Spring Cloud</h3><ul><li>Spring boot 是 Spring 的一套快速配置脚手架，可以基于spring boot 快速开发单个微服务</li><li>Spring Cloud是一个基于Spring Boot实现的云应用开发工具</li><li>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架</li><li>spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring boot来实现</li><li>spring boot不是微服务技术,spring cloud才是微服务技术</li><li>spring boot 特点<ul><li>快速开发spring应用的框架</li><li>内嵌tomcat和jetty容器，不需要单独安装容器，jar包直接发布一个web应用</li><li>简化maven配置，parent这种方式，一站式引入需要的各种依赖</li><li>基于注解的零配置思想</li><li>和各种流行框架，spring web mvc，mybatis，spring cloud无缝整合</li></ul></li></ul><h3 id="Dubbo（读音同double）"><a href="#Dubbo（读音同double）" class="headerlink" title="Dubbo（读音同double）"></a>Dubbo（读音同double）</h3><ul><li>dubbo是阿里巴巴开源的一个高性能分布式服务框架，使得应用可以通过高性能的RPC实现服务的输出和输入，可以与spring无缝集成</li><li>dubbo是高性能，轻量级的开源java RPC框架，提供三大核心能力：<ul><li>面向接口的远程方法调用（R）</li><li>智能容错和负载均衡（P）</li><li>服务自动注册和发现（C）</li></ul></li><li>Dubbo框架主要是用阿里处理分布式系统中，服务发现与注册以及调用问题的，并且管理调用过程。</li></ul><h4 id="Dubbo分层"><a href="#Dubbo分层" class="headerlink" title="Dubbo分层"></a>Dubbo分层</h4><ul><li>业务层：service</li><li>RPC层：config（配置）、proxy（代理）、registry（注册）、cluster（集群）、monitor（监控）、protocol（协议）</li><li>remoting层：exchange（交换）、transprot（运输）、serizlize（序列号）</li></ul><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">service</td><td align="left">业务层，业务代码的实现，应用开发者工作在这一层</td></tr><tr><td align="left">config</td><td align="left">配置层，用来初始化配置信息，用来管理Dubbo的配置</td></tr><tr><td align="left">proxy</td><td align="left">代理层，Dubbo中生产中(provider)和消费者(Consumer)都会生成Proxy， 他用来调用远程接口，就像调用本地接口一样，使得调用透明</td></tr><tr><td align="left">registry</td><td align="left">注册层，负责框架的服务注册和发现</td></tr><tr><td align="left">Cluster</td><td align="left">集群容错层，负责远程调用的容错策略，负载均衡策略以及路由策略</td></tr><tr><td align="left">monitor</td><td align="left">监控层，负责监控调用次数和调用时间</td></tr><tr><td align="left">Protocol</td><td align="left">远程调用层，封装调用的具体过程</td></tr><tr><td align="left">Exchange</td><td align="left">信息交互层，建立Request-Responst模型，分装请求响应模式。例如：转化同步请求为异步请求</td></tr><tr><td align="left">Transport</td><td align="left">网络传输层，Dubbo将网络传输封装成统一接口，可以在这之上扩展更多的网络传输方式</td></tr><tr><td align="left">Serialize</td><td align="left">序列化层，负责网络传输的序列化和反序列化</td></tr></tbody></table><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul><li>https协议需要使用CA证书，一般都是收费的</li><li>http协议运行在tcp上，内容传输是明文的；https协议运行在SSL/TLS上，SSL/TLS运行在TCP上，所有传输都是加密的</li><li>http与https是完全不同的连接方式，用的端口也不一样，http是80，https是443</li><li>https可以有效的防止运营商劫持</li><li>总的来说，https比http要安全很多</li></ul><h3 id="http（1-x）的SPDY优化"><a href="#http（1-x）的SPDY优化" class="headerlink" title="http（1.x）的SPDY优化"></a>http（1.x）的SPDY优化</h3><ul><li>降低延迟：引用了多路复用（multiplexing）（主要原理同线程池），共享一个tcp连接，切记，这里指的共享是通道共享，即不用重新创立通道，但是必须发送一个请求并接到响应后才能发送下一个请求。</li><li>请求优先级：引用多路复用后为了避免主要请求被阻塞，则引入请求优先级</li><li>header压缩：头中很多固定的东西，所以优化了header的压缩方式</li><li>基于https的加密协议传输：使用了https的加密协议，提高安全性</li><li>服务端推送（server push）：假如使用了A.css文件，服务器会同时将a.css中使用的b.js也推送过来，不用重新请求了，直接从内存中获取js文件即可。</li></ul><h3 id="http2-0，SPDY的升级版"><a href="#http2-0，SPDY的升级版" class="headerlink" title="http2.0，SPDY的升级版"></a>http2.0，SPDY的升级版</h3><ul><li>http2.0支持明文的http传输，而SPDY强制使用https（非明文）</li><li>http2.0的头再次优化，http2.0使用HPACK，而SPDY使用的是DEFLATE</li></ul><h3 id="http2-0与http1-x相比"><a href="#http2-0与http1-x相比" class="headerlink" title="http2.0与http1.x相比"></a>http2.0与http1.x相比</h3><ul><li>新的二进制格式：http1.x是基于文本进行的解析，文本解析效率低于二进制解析机制</li><li>多路复用：这里的多路复用在http1.x的路线复用基础上，实现了可以同时发送多个请求，并相应多个请求，请求与相应通过requese产生的id进行关联。web请求默认请求通道是7个</li><li>header压缩：再次优化头压缩方式，并通讯双方各自cache一份header fields（其实就是字典）</li><li>http2.0与SPDY一样支持server push</li><li>http2.0兼容 https、http1.x、http1.0</li><li>如果升级需要从http1.x升级到https再升级到http2.0（Nginx就具备升级条件，参考相关文档即可，方便快捷）</li></ul><h3 id="WBS-工作分解结构"><a href="#WBS-工作分解结构" class="headerlink" title="WBS 工作分解结构"></a>WBS 工作分解结构</h3><ul><li>工作分解结构(work breakdown structure)是把项目工作按阶段可交互成果分解成较小的，易于管理的组成部分的过程。</li><li>WBS归纳和定义了项目的整个工作范围每下降一层，代码对项目工作的更详细定义。WBS是计划过程的中心，也是制定进度计划、资源需求、成本预算、风险管理计划和采购计划的重要基础。WBS还是项目变更的重要基础。</li></ul><h4 id="结构化编码"><a href="#结构化编码" class="headerlink" title="结构化编码"></a>结构化编码</h4><ul><li>编码是最显著和最关键的WBS构成因子，首先编码用于将WBS彻底的结构化。通过编码体系，可以很容易的识别WBS元素的层级关系、分组类别和特性</li><li>并且通过编码使WBS信息与组织结构信息、成本数据、进度数据、合同信息、产品数据、报告信息等紧密的联系起来</li></ul><h4 id="工作包-work-package"><a href="#工作包-work-package" class="headerlink" title="工作包(work package)"></a>工作包(work package)</h4><ul><li>工作包是WBS的最底层元素，一般的工作包是最新的可交付成果。通过工作包可以识别出完成它的活动、成本和组织以及资源信息</li></ul><h4 id="WBS元素"><a href="#WBS元素" class="headerlink" title="WBS元素"></a>WBS元素</h4><ul><li>WBS元素实际上就是WBS结构上的一个个节点，通俗的理解就是组织机构图上的一个个方框，这些防控代表了独立的、具有隶属关系的可交付成果</li></ul><h3 id="分布式系统简介"><a href="#分布式系统简介" class="headerlink" title="分布式系统简介"></a>分布式系统简介</h3><ul><li>分布式组成总体结构：<ul><li>前端展示与操作</li><li>分布式组件<ul><li>后端存储系统</li><li>后端计算系统</li><li>各种中间件（消息中间件、远程过程调用中间件、数据库访问中间件等）</li><li>集群管理系统（分布式协调组件）</li></ul></li><li>单机组件<ul><li>单机操作系统（Linux、windows等）</li><li>硬件、网络等</li></ul></li></ul></li><li>分布式系统一般都有对应的web前端，提供用户随时随地的访问；或者有移动端、桌面端也是可以的</li><li>分布式一定要有一个强大而稳定的后端进行支撑，一般基于Linux，主要原因是开源操作系统成本低，开源软件可以定制</li><li>分布式中有很多的系统组成了一个集群，所以需要对集群进行管理，从而衍生出了一些非常重要的协调组件。用来协调不同机器之间的工作，这个协调系统大都基于一些著名的分布式一致性协议（如Paxos、Raft等）。这些系统不仅要支持分布式协调功能，还要有资源的管理和分配功能。</li><li>为了满足大规模数据的存储需要，要有海量数据后端存储系统。</li><li>为了满足大规模的计算需要，要有能够分析海量数据的后端计算系统。</li><li>分布式的扩展一般分为水平扩展和垂直扩展<ul><li>水平扩展是指通过增加额外的节点来扩展系统的处理能力</li><li>垂直扩展是指通过升级单个节点（CPU、内存、硬盘）来进行扩展</li></ul></li></ul><h4 id="分布式存储系统"><a href="#分布式存储系统" class="headerlink" title="分布式存储系统"></a>分布式存储系统</h4><h5 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h5><ul><li>强一致性<ul><li>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。但是这种实现对性能影响较大。</li></ul></li><li>弱一致性<ul><li>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。</li></ul></li><li>最终一致性（采用最终一致性的数据库系统，NoSQL）<ul><li>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</li></ul></li><li>最终一致性模型的变种<ul><li>因果一致性：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。</li><li>读己所写一致性：因果一致性的特定形式。一个进程总可以读到自己更新的数据。</li><li>会话一致性：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。</li><li>单调读一致性：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。</li><li>单调写一致性：系统保证对同一个进程的写操作串行化。</li></ul></li><li>上述最终一致性的不同方式可以进行组合，例如单调读一致性和读己之所写一致性就可以组合实现。并且从实践的角度来看，这两者的组合，读取自己更新的 数据，和一旦读取到最新的版本不会再读取旧版本，对于此架构上的程序开发来说，会少很多额外的烦恼。</li><li>采用最终一致性的数据库系统，统称为NoSQL（Not only SQL）系统，根据数据库模型的不同，NoSQL系统又分为以下几大类<ul><li>基于键值对的：Memcached、Redis</li><li>基于列存储的：Google BigTable、Apache HBase、Apache Cassandra</li><li>基于文档的：MongoDB、CouchDB</li><li>基于图的：Neo4j、OrientDB</li></ul></li></ul><h5 id="事物的ACID属性（分布式中数据库事物）"><a href="#事物的ACID属性（分布式中数据库事物）" class="headerlink" title="事物的ACID属性（分布式中数据库事物）"></a>事物的ACID属性（分布式中数据库事物）</h5><ul><li>原子性（Atomicity）<ul><li>原子性是指事物是一个不可分割的工作单位，事物中的操作要么都发生，要么都不发生</li></ul></li><li>一致性（Consistency）<ul><li>事物必须是数据库从一个一致性状态变换到另一个一致性状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事物的执行不能被其他事物干扰，即一个事物的内部操作及使用的数据对并发的其他事物是隔离的，并发执行的各个事物之间不能互相干扰</li></ul></li><li>持久性（Durability）<ul><li>一个事物一旦被提交，它对数据库的改变是永久性的，接下来的操作和数据库故障不应该对其有任何影响</li></ul></li></ul><h5 id="分布式CAP（分布式中数据库事物）"><a href="#分布式CAP（分布式中数据库事物）" class="headerlink" title="分布式CAP（分布式中数据库事物）"></a>分布式CAP（分布式中数据库事物）</h5><ul><li>由于在分布式中，无法保证ACID的一致性（Consistency），即分布式服务中如果某一个存储服务宕机后，其他存储服务可以继续运行，且不受影响。所以不适用ACID属性。</li><li>一致性（Consistency）<ul><li>指数据不同副本之间的一致性</li></ul></li><li>可用性（Availability）<ul><li>每个请求都能接受到一个响应，无论相应成功或失败</li></ul></li><li>分区容错（Partition Tolerance）<ul><li>系统应该能持续提供服务，即使系统内部有消息丢失</li></ul></li><li>大部分情况下，系统设计都会保留P属性，在C和A之间进行二选一<ul><li>CP系统：Google BigTable，HBase，MongoDB，Redis，MemCacheDB，这些存储架构都是放弃了高可用性（Avaibility）而选择CP属性的</li><li>AP系统：Amazon Dynamo系统以及它的衍生系统Apcache Cassandra和Voldemort都是属于AP系统</li><li>CA系统：Apache Kafka是一个比较经典的CA系统</li></ul></li></ul><h5 id="BASE（分布式中数据库事物）"><a href="#BASE（分布式中数据库事物）" class="headerlink" title="BASE（分布式中数据库事物）"></a>BASE（分布式中数据库事物）</h5><ul><li>BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。Redis等众多系统构建于这个理论之上。</li><li>基本可用（Basically Available）<ul><li>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</li></ul></li><li>软状态（ Soft State）<ul><li>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</li></ul></li><li>最终一致性（ Eventual Consistency）<ul><li>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul></li></ul><h5 id="SLA服务等级协议（service-level-agreement）"><a href="#SLA服务等级协议（service-level-agreement）" class="headerlink" title="SLA服务等级协议（service level agreement）"></a>SLA服务等级协议（service level agreement）</h5><ul><li>是在一定开销下为保障服务的性能和可用性，服务提供商与用户间定义的一种双方认可的协定。通常这个开销是驱动提供服务质量的主要因素</li><li>一般SLA等级分为2个9、3个9、4个9、5个9…..，9越多代表全年服务可用时间越长服务更可靠，停机时间越短，反之亦然。<ul><li>计算方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    1年 &#x3D; 365天 &#x3D; 8760小时</span><br><span class="line">    99.9 &#x3D; 8760 * 0.1% &#x3D; 8760 * 0.001 &#x3D; 8.76小时</span><br><span class="line">    99.99 &#x3D; 8760 * 0.0001 &#x3D; 0.876小时 &#x3D; 0.876 * 60 &#x3D; 52.6分钟</span><br><span class="line">    99.999 &#x3D; 8760 * 0.00001 &#x3D; 0.0876小时 &#x3D; 0.0876 * 60 &#x3D; 5.26分钟</span><br><span class="line">    &#96;&#96;&#96; </span><br><span class="line">#### 分布式计算系统</span><br><span class="line">##### 批处理分布式计算系统</span><br><span class="line">- 主要采用MapReduce方式进行批处理，特征是</span><br><span class="line">    - 数据集能够被拆分</span><br><span class="line">    - 可以单独进行计算，不同数据集之间没有依赖</span><br><span class="line">    - 计算对实时性要求不高，这是因为MapReduce计算的过程非常耗时</span><br><span class="line">- 主要结构为：</span><br></pre></td></tr></table></figure>map(&lt;K1,V1&gt;) –&gt; list(&lt;K2,V2&gt;)<br>reduce(&lt;K2,list(V2)&gt;) –&gt; list(V3)<br>```<h5 id="流处理分布式计算系统"><a href="#流处理分布式计算系统" class="headerlink" title="流处理分布式计算系统"></a>流处理分布式计算系统</h5></li></ul></li><li>对于那些不断有新数据进来，而且对实时性要求很高的计算，MapReduce就不适用了，于是流处理应运而生。</li><li>流处理分为两大类<ul><li>微批处理（micro-batch processing）系统<ul><li>当新数据到达时，并不立即进行处理，而是等待一段时间后，然后将这一段时间内到达的数据成批处理。这类系统的例子有Apache Spark</li></ul></li><li>真正的流处理（true stream processing）系统<ul><li>当一条新数据到达后，立即进行处理，这类系统的例子有Apache Storm、Apache Samza、 Kafka Streams</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式系统设计总鉴&quot;&gt;&lt;a href=&quot;#分布式系统设计总鉴&quot; class=&quot;headerlink&quot; title=&quot;分布式系统设计总鉴&quot;&gt;&lt;/a&gt;分布式系统设计总鉴&lt;/h2&gt;&lt;h3 id=&quot;SOA面向服务架构&quot;&gt;&lt;a href=&quot;#SOA面向服务架构&quot; class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>灵光一闪</title>
    <link href="http://yoursite.com/2020/05/14/lgys/"/>
    <id>http://yoursite.com/2020/05/14/lgys/</id>
    <published>2020-05-14T06:02:19.000Z</published>
    <updated>2020-06-03T02:32:46.454Z</updated>
    
    <content type="html"><![CDATA[<p>不想写标题</p><a id="more"></a><h2 id="《Android架构师实战指南》灵光一闪总结"><a href="#《Android架构师实战指南》灵光一闪总结" class="headerlink" title="《Android架构师实战指南》灵光一闪总结"></a>《Android架构师实战指南》灵光一闪总结</h2><ul><li>架构的核心就是功能、安全、性能和稳定。</li><li>架构师需要考虑的点有：具备客户要求的功能、能够在要求的工期内安全的构建、性能足够好、可靠、可用且使用时不会造成伤害、安全、成本可接受、符合法规标准、将超越前任以及其他竞争者。</li><li>架构师玩的是折中的游戏，需要根据现有情况、条件、需求来找到一个最好的平衡点，所以没有唯一的正确架构和唯一的正确答案。</li></ul><h3 id="知识点篇"><a href="#知识点篇" class="headerlink" title="知识点篇"></a>知识点篇</h3><ul><li>多继承方式：使用内部类进行继承，可是实现多继承，例如MyApplication继承BasicApplication，内部类Application继承BaseApplication。</li><li>使用代理模式可进行bug统计和log输出，特别好用，也可用于使用在方法过滤中。</li><li>当大量使用第三方网络库时，良好的习惯是封装、封装、封装。因为只有自己封装一层，才能够统一实现入口的逻辑。</li></ul><h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><ul><li>UML图工具：Enterprise Architect、Gliffy</li><li>思维导图：XMind、iMindMap</li><li>原型设计：Axure、OmniGraffle（Mac）、Justinmind</li><li>产品演示：PPT</li><li>图像绘制：Visio、Adobe系列（PS/AI/AE)、Keynote、Pixate(交互设计)</li><li>辅助工具：MarkMan、Sip、石墨文档（在线协作文档）、Google Drive（文档协作/项目管理）</li><li>抓包工具：fillder、Charles</li></ul><h3 id="设备卡顿原因与处理"><a href="#设备卡顿原因与处理" class="headerlink" title="设备卡顿原因与处理"></a>设备卡顿原因与处理</h3><ul><li>设备卡顿一般情况下是由于CPU、GPU、内存、线程导致的app卡顿。<ul><li>CPU与GPU造成的卡顿可以在UI和布局上进行优化，减少无用的view构建可以减少CPU的压力，减少无用的绘制可以减少GPU的压力。在view绘制流程中，减少onLayout与onMeasure中的工作量会减少CPU的压力，减少onDraw中的工作量会减少GPU的压力。</li><li>内存，内存优化与处理，尽量使用懒加载，减少超大图片的使用，详见内存机制与原理篇。</li><li>线程，主要是ANR（Application Not Responding，应用无响应）状态，可以减少Service、Broadcast Receiver的数量和初始化状态，采用懒加载。减少应用瞬时的初始化数量。</li></ul></li></ul><h3 id="java内存机制"><a href="#java内存机制" class="headerlink" title="java内存机制"></a>java内存机制</h3><h4 id="java内存区域-分为方法区、堆、栈、以及程序计数器"><a href="#java内存区域-分为方法区、堆、栈、以及程序计数器" class="headerlink" title="java内存区域 分为方法区、堆、栈、以及程序计数器"></a>java内存区域 分为方法区、堆、栈、以及程序计数器</h4><ul><li>方法区（Method Area） 最大容量64MB，主要存放方法、属性、静态成员等。所有线程共享内存区域，属于持久代。<ul><li>在 JDK1.8中，为防止方法区内存溢出，将方法区改为元数据区，并将其放到了对外内存（本地内存）中了，那么他的大小就不在受限于JVM了。</li></ul></li><li>堆（Heap） 最大容量64MB，存放对象所持有的数据，同时保持对原类的引用。所有线程共享内存区域。</li><li>栈（Stack） 分为虚拟机栈（JVM Stacks）与本地方法栈（Native Method Stacks）。默认最大容量1MB，方法被调用后，java虚拟机（JVM）会回收栈占用的内存，线程私有内存区域。<ul><li>虚拟机栈（JVM Stacks）用于存储局部变量、动态链接、操作数、方法出口等信息。有两种异常情况StackOverFlowError、OutOfMemoryError。</li><li>本地方法栈（Native Method Stacks）主要为Native提供方法服务，</li></ul></li><li>程序计数器（Program Counter Register）可以看做是当前线程执行字节码的行号指示器，位于CPU中，程序不能直接对其操作，每个线程都有独立的计数器，线程私有内存区域。</li><li>GC。Garbage Collection/Collector,垃圾回收/回收器。用户分配内存，确保被引用对象保留在内存中，以及回收不存在引用关系的对象内存，基本算法是分代收集，针对内存区域中的本地方法栈与对进行回收，新生代、旧生代、长久代采用不用的GC算法。</li></ul><h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><ul><li>内存溢出通常是由于内存泄漏导致，或者加重超大图片资源bitmap导致内存溢出问题</li><li>内存泄漏，我们都知道，当一个对象在jvm中如果没有到达GC roots（根对象）的路径时为不可达状态，不可达状态时会被GC回收，而内存泄漏就是指某些对象可达却无用的状态。这时就要通过工具（profiler）进行内存跟踪，并结合代码进行梳理找到内存泄漏原因。<ul><li>持有Activity、Context、View、Drawable这些对象时，不要去处理Theard、第三方初始化或异步程序。当异步程序生命周期大于当前生命周期时会导致内存泄漏。</li><li>内部类、匿名类等。道理同上，内部类或匿名类可能因为生命周期不同步，造成一定程度的内存泄漏。</li></ul></li><li>内存优化<ul><li>减少Service的使用，尽力使用IntentService进行服务的工作。</li><li>监听内存使用情况，当UI不可见或内存紧张时释放内存。在Activity的回调方法onTrimMemory(int level)中，根基level的不同释放内存。</li><li>使用bitmap时要尽力保证分辨率与屏幕分辨率一致。</li><li>使用SparseArray、SparseBooleanArray、LongSparseArray等优化的数据容器代替HashMap</li><li>少使用抽象类</li><li>尽量少使用依赖注入的工具类</li><li>apk打包签名时，使用zipalign工具对齐</li><li>使用多线程</li><li>主动使用GC</li><li>finally调用与重写</li></ul></li></ul><h3 id="app保活"><a href="#app保活" class="headerlink" title="app保活"></a>app保活</h3><p>app保活指的是保护app，让app活着，在android OS发展越来越快和越来越严格的环境下，如今保活已经是一种奢望，但是提高app的保活率和提高保活状态还是可以的。</p><p>android中主要通过LMK（Low Memory Killer）来对进程进行回收管理，LMK是在Android系统内存不足而选择kill部分进程以释放空间的决定者。</p><h4 id="app被系统回收或杀死优先级"><a href="#app被系统回收或杀死优先级" class="headerlink" title="app被系统回收或杀死优先级"></a>app被系统回收或杀死优先级</h4><ul><li>前台进程，正在与用户进行交互的进程。</li><li>可见进程，会影响用户所见内容的进程，如处于onPause的Activity。</li><li>服务进程，如正在运行startService的Service。</li><li>后台进程，对用户交互无影响，例如处于onStop的activity。</li><li>空进程，一般作用缓存，以缩短下次使用时间，例如被切到后台的后台进程，然后被系统回收，但是处于温启动状态下的app。</li></ul><h4 id="保活方法"><a href="#保活方法" class="headerlink" title="保活方法"></a>保活方法</h4><p>有上面的优先级可知进程被杀死或回收的顺序，和LMK的回收原理，那么如果提高app的优先级则可以有效提高app的保活率。</p><p>前台进程、可见进程属于不可控方向。所以我们需要尽量保证app处于服务进程或后台进程，避免app处于空进程中。</p><ul><li>网络连接保活方法，建立长连接</li><li>双service（通知栏）提高进程优先级</li><li>Service及时拉起</li><li>守护进程、进程互拉</li></ul><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>looper翻译一下是回路、循环的意思。在android中也一样，代表一个可以无限的死循环。</p><ul><li>启动过程<ul><li>looper创建时会同时创建一个MessageQueue，每个线程有一个looper、一个MessageQueue、多个Handler</li><li>主线程：<ul><li>主线程中会自动创建looper，即执行looper.prepare(),looper.loop();</li><li>当主线程的looper退出循环，则意味着主线程结束，程序退出</li></ul></li><li>子线程：<ul><li>子线程的looper可有可无，在需要的时候创建，然后looper.loop()开始循环，代表着无限死循环执行下去。如果再looper.loop()后面写的代码不会执行。</li><li>子线程中如果要写handler，则必须有looper，因为在handler的构造方法中，会执行Looper.myLooper()；方法，如果获取looper为空，则会抛出异常RuntimeException。</li></ul></li></ul></li><li>looper循环<ul><li>在looper创建(looper.prepare())之后，looper循环(looper.loop())之前的代码会无限死循环执行。</li><li>在Android中，生命周期的回调、方法的执行、交互的方式等等都是通过looper的循环进行message事件的分发。</li><li>在子线程如果创建了looper，且looper退出循环代表子线程结束</li><li>在主线程中必然存在looper，如果退出了looper循环，代表主线程结束，程序退出</li><li>每个线程至多只有一个looper，主线程必定有looper，子线程不一定有looper。</li><li>每个handler的创建必然有looper，子线程的handler创建需要先创建looper.prepare()，然后创建handler，然后执行looper.loop()才能够创建并执行handler机制。</li></ul></li><li>当Looper从MessageQueue中摘取消息时，如果队列上没有消息，则looper线程会进入阻塞，知道其他线程插入消息后，唤醒当前线程才会继续执行。</li><li>looper的退出<ul><li>主线程：主线程的looper是不能够退出的</li><li>子线程：子线程有quit和quitSafely两种退出方式，本质都是调用quit(boolean safe)方法进行退出，再往下调用的两个方法是：<ul><li>removeAllFutureMessagesLocked();清空延时消息，不延时的消息，依旧让他执行完，再退出</li><li>removeAllMessagesLocked();全部清空，并退出</li></ul></li></ul></li></ul><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><ul><li>MessageQueue是在Looper创建时同时创建的一个消息队列</li><li>在使用Handler进行消息插入时，最后Handler会调用handler.sendMessageAiTime();通过looper将message插入到MessageQueue中，所以looper、MessageQueue都是添加同步锁的</li><li>MessageQueue中的默认Message线程池线程数量为50，在Message线程池消息池中主要方法有两个，obtain和recycle，且方法是需要加同步锁的。<ul><li>obtain：负责从线程池中取出一个干净的Message</li><li>recycl：后者将使用完的Message清理干净，并放回线程池中</li></ul></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>java中一般认为有23种设计模式，我们不需要都体会，只需要掌握及种设计模式就可以了。</li><li>创建型模式，共五种：工长方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li>结构性模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li>行为型模式，共十一种：侧罗模式、模板方式模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式分为懒汉式、饿汉式。</p><ul><li>饿汉式：饿汉式实在声明静态全局变量时，就直接将该单例对象new出来的方式。</li><li>懒汉式：声明变量时不会直接创建对象本身，而是在构造方法中进行线程安全处理，加入synchronized锁，并在声明变量时使用volatile进行修饰。</li></ul><h4 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h4><ul><li>工厂设计模式分为工厂方法模式和抽象工厂模式</li><li>封装很多的overview可以认为是一种工厂模式的典型使用，通过定义overview进行工厂基础的封装，然后其他overview实现该接口进行不同功能的具体实现</li></ul><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><ul><li>普通工厂模式就是建立一个工厂类，对实现了统一接口的一些类进行实例的创建</li><li>多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。 </li><li>静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5></li><li>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><ul><li>建造者模式通过builder将对象build出来，然后通过简单的方式将对象进行处理</li><li>例如地图量测小工具，通过build进行创建，并使用小工具进行量测功能</li></ul><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><ul><li>适配器模式可以认为是简易化的中间件，具体是将两个不兼容的对象通过适配器进行联通并使用</li></ul><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><ul><li>观察者模式的核心是接口回调，而接口回调也可以认为是简单的观察者模式。</li><li>例如定位组件的监听器，通过注册的方式使观察者注册进来，观察被观察者定位的改变。</li></ul><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><ul><li>策略模式可以使封装一个统一的接口，然后其他的具体实现使用这个接口进行具体实现，外部调用方式都是同一个方法</li><li>量测模块中的具体算法量测calcalator可以认为是一个策略模式，使用不同的计算模块实现计算方式</li></ul><h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><ul><li>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>设计模式是一种认为定制的模式，而在实际开发中，在不理解或没有认知到某些模式的时候，已经无意间使用了很多的模式。不要因为要使用某种模式而去使用模式，应该是在开发过程中顺其自然的使用了某种模式后根据这种模式去完善。</li><li>设计模式的初衷是提高代码效率，高内部低耦合的原则。</li></ul><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><ul><li>不要重复造轮子，网络库很好，如果不好一定是没找好，既然好为什么不用呢。不要把精力放在重复的事情上。</li><li>专业的事情交给专业的人去做。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不想写标题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="一闪一闪亮晶晶" scheme="http://yoursite.com/tags/%E4%B8%80%E9%97%AA%E4%B8%80%E9%97%AA%E4%BA%AE%E6%99%B6%E6%99%B6/"/>
    
  </entry>
  
</feed>
