<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-14T06:05:51.974Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>灵光一闪</title>
    <link href="http://yoursite.com/2020/05/14/lgys/"/>
    <id>http://yoursite.com/2020/05/14/lgys/</id>
    <published>2020-05-14T06:02:19.000Z</published>
    <updated>2020-05-14T06:05:51.974Z</updated>
    
    <content type="html"><![CDATA[<p>不想写标题</p><a id="more"></a><h2 id="《Android架构师实战指南》灵光一闪总结"><a href="#《Android架构师实战指南》灵光一闪总结" class="headerlink" title="《Android架构师实战指南》灵光一闪总结"></a>《Android架构师实战指南》灵光一闪总结</h2><ul><li>架构的核心就是功能、安全、性能和稳定。</li><li>架构师需要考虑的点有：具备客户要求的功能、能够在要求的工期内安全的构建、性能足够好、可靠、可用且使用时不会造成伤害、安全、成本可接受、符合法规标准、将超越前任以及其他竞争者。</li><li>架构师玩的是折中的游戏，需要根据现有情况、条件、需求来找到一个最好的平衡点，所以没有唯一的正确架构和唯一的正确答案。</li></ul><h3 id="知识点篇"><a href="#知识点篇" class="headerlink" title="知识点篇"></a>知识点篇</h3><ul><li>多继承方式：使用内部类进行继承，可是实现多继承，例如MyApplication继承BasicApplication，内部类Application继承BaseApplication。</li><li>使用代理模式可进行bug统计和log输出，特别好用，也可用于使用在方法过滤中。</li><li>当大量使用第三方网络库时，良好的习惯是封装、封装、封装。因为只有自己封装一层，才能够统一实现入口的逻辑。</li></ul><h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><ul><li>UML图工具：Enterprise Architect、Gliffy</li><li>思维导图：XMind、iMindMap</li><li>原型设计：Axure、OmniGraffle（Mac）、Justinmind</li><li>产品演示：PPT</li><li>图像绘制：Visio、Adobe系列（PS/AI/AE)、Keynote、Pixate(交互设计)</li><li>辅助工具：MarkMan、Sip、石墨文档（在线协作文档）、Google Drive（文档协作/项目管理）</li><li>抓包工具：fillder、Charles</li></ul><h3 id="设备卡顿原因与处理"><a href="#设备卡顿原因与处理" class="headerlink" title="设备卡顿原因与处理"></a>设备卡顿原因与处理</h3><ul><li>设备卡顿一般情况下是由于CPU、GPU、内存、线程导致的app卡顿。<ul><li>CPU与GPU造成的卡顿可以在UI和布局上进行优化，减少无用的view构建可以减少CPU的压力，减少无用的绘制可以减少GPU的压力。在view绘制流程中，减少onLayout与onMeasure中的工作量会减少CPU的压力，减少onDraw中的工作量会减少GPU的压力。</li><li>内存，内存优化与处理，尽量使用懒加载，减少超大图片的使用，详见内存机制与原理篇。</li><li>线程，主要是ANR（Application Not Responding，应用无响应）状态，可以减少Service、Broadcast Receiver的数量和初始化状态，采用懒加载。减少应用瞬时的初始化数量。</li></ul></li></ul><h3 id="java内存机制"><a href="#java内存机制" class="headerlink" title="java内存机制"></a>java内存机制</h3><h4 id="java内存区域-分为方法区、堆、栈、以及程序计数器"><a href="#java内存区域-分为方法区、堆、栈、以及程序计数器" class="headerlink" title="java内存区域 分为方法区、堆、栈、以及程序计数器"></a>java内存区域 分为方法区、堆、栈、以及程序计数器</h4><ul><li>方法区（Method Area） 最大容量64MB，主要存放方法、属性、静态成员等。所有线程共享内存区域，属于持久代。<ul><li>在 JDK1.8中，为防止方法区内存溢出，将方法区改为元数据区，并将其放到了对外内存（本地内存）中了，那么他的大小就不在受限于JVM了。</li></ul></li><li>堆（Heap） 最大容量64MB，存放对象所持有的数据，同时保持对原类的引用。所有线程共享内存区域。</li><li>栈（Stack） 分为虚拟机栈（JVM Stacks）与本地方法栈（Native Method Stacks）。默认最大容量1MB，方法被调用后，java虚拟机（JVM）会回收栈占用的内存，线程私有内存区域。<ul><li>虚拟机栈（JVM Stacks）用于存储局部变量、动态链接、操作数、方法出口等信息。有两种异常情况StackOverFlowError、OutOfMemoryError。</li><li>本地方法栈（Native Method Stacks）主要为Native提供方法服务，</li></ul></li><li>程序计数器（Program Counter Register）可以看做是当前线程执行字节码的行号指示器，位于CPU中，程序不能直接对其操作，每个线程都有独立的计数器，线程私有内存区域。</li><li>GC。Garbage Collection/Collector,垃圾回收/回收器。用户分配内存，确保被引用对象保留在内存中，以及回收不存在引用关系的对象内存，基本算法是分代收集，针对内存区域中的本地方法栈与对进行回收，新生代、旧生代、长久代采用不用的GC算法。</li></ul><h3 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h3><ul><li>内存溢出通常是由于内存泄漏导致，或者加重超大图片资源bitmap导致内存溢出问题</li><li>内存泄漏，我们都知道，当一个对象在jvm中如果没有到达GC roots（根对象）的路径时为不可达状态，不可达状态时会被GC回收，而内存泄漏就是指某些对象可达却无用的状态。这时就要通过工具（profiler）进行内存跟踪，并结合代码进行梳理找到内存泄漏原因。<ul><li>持有Activity、Context、View、Drawable这些对象时，不要去处理Theard、第三方初始化或异步程序。当异步程序生命周期大于当前生命周期时会导致内存泄漏。</li><li>内部类、匿名类等。道理同上，内部类或匿名类可能因为生命周期不同步，造成一定程度的内存泄漏。</li></ul></li><li>内存优化<ul><li>减少Service的使用，尽力使用IntentService进行服务的工作。</li><li>监听内存使用情况，当UI不可见或内存紧张时释放内存。在Activity的回调方法onTrimMemory(int level)中，根基level的不同释放内存。</li><li>使用bitmap时要尽力保证分辨率与屏幕分辨率一致。</li><li>使用SparseArray、SparseBooleanArray、LongSparseArray等优化的数据容器代替HashMap</li><li>少使用抽象类</li><li>尽量少使用依赖注入的工具类</li><li>apk打包签名时，使用zipalign工具对齐</li><li>使用多线程</li><li>主动使用GC</li><li>finally调用与重写</li></ul></li></ul><h3 id="app保活"><a href="#app保活" class="headerlink" title="app保活"></a>app保活</h3><p>app保活指的是保护app，让app活着，在android OS发展越来越快和越来越严格的环境下，如今保活已经是一种奢望，但是提高app的保活率和提高保活状态还是可以的。</p><p>android中主要通过LMK（Low Memory Killer）来对进程进行回收管理，LMK是在Android系统内存不足而选择kill部分进程以释放空间的决定者。</p><h4 id="app被系统回收或杀死优先级"><a href="#app被系统回收或杀死优先级" class="headerlink" title="app被系统回收或杀死优先级"></a>app被系统回收或杀死优先级</h4><ul><li>前台进程，正在与用户进行交互的进程。</li><li>可见进程，会影响用户所见内容的进程，如处于onPause的Activity。</li><li>服务进程，如正在运行startService的Service。</li><li>后台进程，对用户交互无影响，例如处于onStop的activity。</li><li>空进程，一般作用缓存，以缩短下次使用时间，例如被切到后台的后台进程，然后被系统回收，但是处于温启动状态下的app。</li></ul><h4 id="保活方法"><a href="#保活方法" class="headerlink" title="保活方法"></a>保活方法</h4><p>有上面的优先级可知进程被杀死或回收的顺序，和LMK的回收原理，那么如果提高app的优先级则可以有效提高app的保活率。</p><p>前台进程、可见进程属于不可控方向。所以我们需要尽量保证app处于服务进程或后台进程，避免app处于空进程中。</p><ul><li>网络连接保活方法，建立长连接</li><li>双service（通知栏）提高进程优先级</li><li>Service及时拉起</li><li>守护进程、进程互拉</li></ul><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>looper翻译一下是回路、循环的意思。在android中也一样，代表一个可以无限的死循环。</p><ul><li>启动过程<ul><li>looper创建时会同时创建一个MessageQueue，每个线程有一个looper、一个MessageQueue、多个Handler</li><li>主线程：<ul><li>主线程中会自动创建looper，即执行looper.prepare(),looper.loop();</li><li>当主线程的looper退出循环，则意味着主线程结束，程序退出</li></ul></li><li>子线程：<ul><li>子线程的looper可有可无，在需要的时候创建，然后looper.loop()开始循环，代表着无限死循环执行下去。如果再looper.loop()后面写的代码不会执行。</li><li>子线程中如果要写handler，则必须有looper，因为在handler的构造方法中，会执行Looper.myLooper()；方法，如果获取looper为空，则会抛出异常RuntimeException。</li></ul></li></ul></li><li>looper循环<ul><li>在looper创建(looper.prepare())之后，looper循环(looper.loop())之前的代码会无限死循环执行。</li><li>在Android中，生命周期的回调、方法的执行、交互的方式等等都是通过looper的循环进行message事件的分发。</li><li>在子线程如果创建了looper，且looper退出循环代表子线程结束</li><li>在主线程中必然存在looper，如果退出了looper循环，代表主线程结束，程序退出</li><li>每个线程至多只有一个looper，主线程必定有looper，子线程不一定有looper。</li><li>每个handler的创建必然有looper，子线程的handler创建需要先创建looper.prepare()，然后创建handler，然后执行looper.loop()才能够创建并执行handler机制。</li></ul></li><li>当Looper从MessageQueue中摘取消息时，如果队列上没有消息，则looper线程会进入阻塞，知道其他线程插入消息后，唤醒当前线程才会继续执行。</li><li>looper的退出<ul><li>主线程：主线程的looper是不能够退出的</li><li>子线程：子线程有quit和quitSafely两种退出方式，本质都是调用quit(boolean safe)方法进行退出，再往下调用的两个方法是：<ul><li>removeAllFutureMessagesLocked();清空延时消息，不延时的消息，依旧让他执行完，再退出</li><li>removeAllMessagesLocked();全部清空，并退出</li></ul></li></ul></li></ul><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><ul><li>MessageQueue是在Looper创建时同时创建的一个消息队列</li><li>在使用Handler进行消息插入时，最后Handler会调用handler.sendMessageAiTime();通过looper将message插入到MessageQueue中，所以looper、MessageQueue都是添加同步锁的</li><li>MessageQueue中的默认Message线程池线程数量为50，在Message线程池消息池中主要方法有两个，obtain和recycle，且方法是需要加同步锁的。<ul><li>obtain：负责从线程池中取出一个干净的Message</li><li>recycl：后者将使用完的Message清理干净，并放回线程池中</li></ul></li></ul><h3 id="SOA面向服务架构"><a href="#SOA面向服务架构" class="headerlink" title="SOA面向服务架构"></a>SOA面向服务架构</h3><ul><li>面向服务设计范式的设计原则<ul><li>标准化服务契约：服务遵循相同的契约设计标准。</li><li>服务松散耦合：服务契约对服务消费者松耦合，服务之间松耦合。</li><li>服务抽象：服务契约仅包含必要信息，并且关于服务的信息局限为服务契约中发布的信息。</li><li>服务可重用性：服务可作为重用资源。</li><li>服务自治：服务对其底层运行时执行环境有很大的控制权。</li><li>服务无状态性：服务无状态保证了服务部署的横向扩展性。</li><li>服务可发现性：服务可通过描述性元数据有效发现并解释服务。</li><li>服务可组合性：可以通过组合叠合原子服务形成复杂上层业务服务。</li></ul></li><li>SOA架构的基本原则是降低服务间的耦合度，使服务可以类似于模块或组件的形式进行配合使用。<ul><li>模块化服务使用</li><li>服务间低耦合</li><li>类似于oauth的方式使用服务，使服务间通过网络进行调用</li></ul></li><li>SOA与微服务的区别<ul><li>SOA面向大块业务逻辑，微服务属于单独任务或小块业务逻辑</li><li>SOA着重于中央管理，微服务着重分散管理</li><li>SOA确保能够交互操作，微服务确保执行新功能、快速拓展开发团队</li></ul></li></ul><h3 id="kubernetes（K8S）"><a href="#kubernetes（K8S）" class="headerlink" title="kubernetes（K8S）"></a>kubernetes（K8S）</h3><ul><li>企业级微服务框架</li><li>node是集群中的工作节点，运行真正的应用程序，在node上k8s管理的最小运行单元是Pod。<ul><li>node上运行着k8s以及相关服务进程，这些服务进程负责pod的创建、启动、监控、重启、销毁、以及实现软件模式的负载均衡</li></ul></li><li>Pod是k8s的最基本的操作单元，包含一个或多个紧密相关的容器，一个Pod可以被一个容器换的环境看做应用层的“逻辑宿主机”</li><li>Pod在k8s的世界中，每一个pod会分配一个ip地址，但这个ip地址会随着pod的销毁而消失，这就有一个问题了，如果一组pod组成的一个集群来提供服务，那么如何来方位它呢？通过Services</li><li>一个services可以看作一组提供相同服务的pod的对外访问接口</li></ul><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li>Nginx是一个代理服务器的角色，为了避免单独一个服务器压力过大，而将来自不同用户的请求发送给不同的服务器，形成1对多的关系的一种技术</li><li>Nginx分配方式<ul><li>权重方式（自定义），轮询进行分配，通过权重提高服务器轮询的几率</li><li>根据ip分配方式，按照基于客户端的ip的分配方式，保障相同客户端的请求一直发送给相同的服务器，可以保证session会话</li><li>最少连接方式</li><li>最快响应方式</li><li>根据url分配（自定义），可以在指定url请求某一台服务器，例如下载某资源时会去同一台服务器去下载，这样会提高利用率</li></ul></li><li>在Nginx中如果有某一台服务器宕机了，那么在Nginx轮询发现后，会将改服务器剔除</li></ul><h3 id="Spring-Boot-与-Spring-Cloud"><a href="#Spring-Boot-与-Spring-Cloud" class="headerlink" title="Spring Boot 与 Spring Cloud"></a>Spring Boot 与 Spring Cloud</h3><ul><li>Spring boot 是 Spring 的一套快速配置脚手架，可以基于spring boot 快速开发单个微服务</li><li>Spring Cloud是一个基于Spring Boot实现的云应用开发工具</li><li>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架</li><li>spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring boot来实现</li><li>spring boot不是微服务技术,spring cloud才是微服务技术</li><li>spring boot 特点<ul><li>快速开发spring应用的框架</li><li>内嵌tomcat和jetty容器，不需要单独安装容器，jar包直接发布一个web应用</li><li>简化maven配置，parent这种方式，一站式引入需要的各种依赖</li><li>基于注解的零配置思想</li><li>和各种流行框架，spring web mvc，mybatis，spring cloud无缝整合</li></ul></li></ul><h3 id="Dubbo（读音同double）"><a href="#Dubbo（读音同double）" class="headerlink" title="Dubbo（读音同double）"></a>Dubbo（读音同double）</h3><ul><li>dubbo是阿里巴巴开源的一个高性能分布式服务框架，使得应用可以通过高性能的RPC实现服务的输出和输入，可以与spring无缝集成</li><li>dubbo是高性能，轻量级的开源java RPC框架，提供三大核心能力：<ul><li>面向接口的远程方法调用（R）</li><li>只能容错和负载均衡（P）</li><li>服务自动注册和发现（C）</li></ul></li></ul><h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul><li>https协议需要使用CA证书，一般都是收费的</li><li>http协议运行在tcp上，内容传输是明文的；https协议运行在SSL/TLS上，SSL/TLS运行在TCP上，所有传输都是加密的</li><li>http与https是完全不同的连接方式，用的端口也不一样，http是80，https是443</li><li>https可以有效的防止运营商劫持</li><li>总的来说，https比http要安全很多</li></ul><h3 id="http（1-x）的SPDY优化"><a href="#http（1-x）的SPDY优化" class="headerlink" title="http（1.x）的SPDY优化"></a>http（1.x）的SPDY优化</h3><ul><li>降低延迟：引用了多路复用（multiplexing）（主要原理同线程池），共享一个tcp连接，切记，这里指的共享是通道共享，即不用重新创立通道，但是必须发送一个请求并接到响应后才能发送下一个请求。</li><li>请求优先级：引用多路复用后为了避免主要请求被阻塞，则引入请求优先级</li><li>header压缩：头中很多固定的东西，所以优化了header的压缩方式</li><li>基于https的加密协议传输：使用了https的加密协议，提高安全性</li><li>服务端推送（server push）：假如使用了A.css文件，服务器会同时将a.css中使用的b.js也推送过来，不用重新请求了，直接从内存中获取js文件即可。</li></ul><h3 id="http2-0，SPDY的升级版"><a href="#http2-0，SPDY的升级版" class="headerlink" title="http2.0，SPDY的升级版"></a>http2.0，SPDY的升级版</h3><ul><li>http2.0支持明文的http传输，而SPDY强制使用https（非明文）</li><li>http2.0的头再次优化，http2.0使用HPACK，而SPDY使用的是DEFLATE</li></ul><h3 id="http2-0与http1-x相比"><a href="#http2-0与http1-x相比" class="headerlink" title="http2.0与http1.x相比"></a>http2.0与http1.x相比</h3><ul><li>新的二进制格式：http1.x是基于文本进行的解析，文本解析效率低于二进制解析机制</li><li>多路复用：这里的多路复用在http1.x的路线复用基础上，实现了可以同时发送多个请求，并相应多个请求，请求与相应通过requese产生的id进行关联。web请求默认请求通道是7个</li><li>header压缩：再次优化头压缩方式，并通讯双方各自cache一份header fields（其实就是字典）</li><li>http2.0与SPDY一样支持server push</li><li>http2.0兼容 https、http1.x、http1.0</li><li>如果升级需要从http1.x升级到https再升级到http2.0（Nginx就具备升级条件，参考相关文档即可，方便快捷）</li></ul><h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><ul><li>不要重复造轮子，网络库很好，如果不好一定是没找好，既然好为什么不用呢。不要把精力放在重复的事情上。</li><li>专业的事情交给专业的人去做。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不想写标题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="一闪一闪亮晶晶" scheme="http://yoursite.com/tags/%E4%B8%80%E9%97%AA%E4%B8%80%E9%97%AA%E4%BA%AE%E6%99%B6%E6%99%B6/"/>
    
  </entry>
  
</feed>
